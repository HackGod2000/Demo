{"version":3,"sources":["Components/images/marsmap1k.jpg","Components/images/marsbump1k.jpg","Components/images/background.jpg","Components/endpage.jsx","Components/Controls.jsx","Components/Startpage.jsx","Components/Model.jsx","Components/algorithms/astar.js","Components/algorithms/Bestfs.js","Components/algorithms/bfs.js","Components/algorithms/bi-dijkstra.js","Components/algorithms/biastar.js","Components/algorithms/BiBestfs.js","Components/algorithms/bibfs.js","Components/algorithms/BiIastar.js","Components/algorithms/dijkstra.js","Components/algorithms/Iastar.js","Components/algorithms/IBestfs.js","Components/algorithms/IDAstar_new.js","Components/algorithms/jps.js","Components/algorithms/orthJPS.js","Components/PathfindingVisualizer/Node.jsx","Components/PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["module","exports","SpaceShip","useState","model","setModel","console","log","useEffect","GLTFLoader","load","object","scene","Loading","finished","set","width","setWidth","THREE","onLoad","onProgress","url","itemsLoaded","itemsTotal","useTransition","from","opacity","leave","update","map","item","key","props","div","className","style","endpage","state","window","height","shadowMap","camera","position","intensity","castShadow","angle","penumbra","shadow-mapSize-width","shadow-mapSize-height","shadow-bias","attach","args","fallback","autoRotate","enablePan","enableZoom","enableDamping","dampingFactor","rotateSpeed","maxPolarAngle","Math","PI","minPolarAngle","href","children","Component","extend","OrbitControls","Controls","controlsRef","useRef","useThree","gl","size","useFrame","current","ref","domElement","enableRotate","Startpage","sleep","ms","Promise","resolve","setTimeout","Mars","mesh","hovered","setHover","active","setActive","imgmars","useMemo","marsURL","bumpmap1","bumperURL","rotation","y","scale","onClick","e","onPointerOver","onPointerOut","color","bumpmap","bumpscale","Model","zoom","bind","enlarge","document","body","backgroundImage","img1","i","j","k","scaled","parseFloat","this","setState","a","location","isReachable","grid","r","c","length","isWall","getneighbors","node","diagonalallowed","neighbors","temp","push","row","col","Heap","require","Astar","startNode","finishNode","h","openList","nodeA","nodeB","fscore","gscore","inopen","b","visitedNodesInOrder","empty","pop","inclosed","neighbor","ng","sqrt","hscore","previousNode","updateItem","Bestfs","heuristic","distance","unvisitedNodes","nodes","getAllNodes","sortNodesByDistance","closestNode","shift","wallweight","Infinity","isVisited","updateUnvisitedNeighbors","sort","unvisitedNeighbors","filter","getUnvisitedNeighbors","value","localeCompare","abs","max","pow","x_dist","y_dist","min","bfs","queue","bidijkstra","TempEnd","TempStart","tempstart","_","cloneDeep","tempend","startvisited","temp1","unshift","endvisited","temp2","closestNodeEnd","unvisitedNeighbors2","next","bidfsans","ans","s","BiAstar","startopenList","endopenList","temp3","enode","temp4","eneighbors","eneighbor","temp5","nex","temp6","BiBestfs","updateUnvisitedNeighborsStart","closestNode2","updateUnvisitedNeighborsEnd","bbfs","startqueue","endqueue","ftNode","unvisitedNeighbor","neighbora","bibfsans","BiIastar","dijkstra","isWallweight","getNodesInShortestPathOrder","nodesInShortestPathOrder","currentNode","Iastar","IBestfs","IDAstar","depth","heurestics","dx","dy","dblock","cX","cY","dX","dY","blocked","direction","sign","identifySuccessors","successors","parent","x","nodeNeighbors","jumpPoint","jump","curr","nX","nY","oX","oY","Node","isFinish","isStart","onDragStart","draggable","onMouseDown","onMouseEnter","onMouseUp","onDrop","extraClassName","ondragover","preventDefault","ondrop","id","dataS","dataF","rowdata","coldata","PathfindingVisualizer","handleonDragDrop","row_i","dataTransfer","getData","col_i","row_f","target","getAttribute","col_f","checkStart","checkFinish","newGrid","newStartPositions","startnoderow","startnodecol","finishnoderow","finishnodecol","handleonDragStart","f","setData","mouseIsPressed","fin","inf","pause","heuristicname","Algo","handleheuristic1","handleheuristic2","handleheuristic3","handleheuristic4","handleOptionChangefinite","handleOptionChangeinfinite","handleChange2","handleSubmit","event","parseInt","prompt","alert","getInitialGrid","getNewGridWithWallToggled","animateShortestPath","getElementById","animate","successor","val","jps","direc","d","diff","l","jpsans","clearFiniteWalls","orthJPS","xcord","ycord","m","orthogonalans","grid1","node1","grid2","type","class","visualizeDijkstra","name","visualizeBiDijkstra","visualizeDijkstraDiag","visualizeBiDijkstraDiag","visualizeBFS","visualizeBBFS","visualizeBFSwithdiagonals","visualizeBDBFS","visualizeIntelligentAstar","visualizeBiIntelligentAstar","visualizeIntelligentAstarDiag","visualizeBiIntelligentAstarDiag","visualizeAstar","visualizeBiAstarNodiagoanls","visualizeOrthAstar","visualizeBiAstarWithDiagonals","visualizeBestfs","visualizeBiBestfs","visualizeBestfsDiag","visualizeBiBestfsDiag","visualizeIBestfs","visualizeIBestfsDiag","visualizeIDAstar","visualizeIDAstarDiag","visualizeJPS","visualizeOrthJPS","checked","onChange","for","tabIndex","clearPath","clearwall","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","createNode","weight","slice","newNode","node_old","node_new","start","end","newNode1","App","exact","path","Boolean","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.16964799.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/marsmap1k.56f226a5.jpg\";","module.exports = __webpack_public_path__ + \"static/media/marsbump1k.f68f2bda.jpg\";","module.exports = __webpack_public_path__ + \"static/media/background.faa1a633.jpg\";","import { OrbitControls } from \"drei\";\nimport React, { Component, Suspense, useEffect, useState } from \"react\";\nimport { a, useTransition } from \"react-spring\";\nimport { Canvas } from \"react-three-fiber\";\nimport * as THREE from \"three\";\nimport { GLTFLoader } from \"three/examples/jsm/loaders/GLTFLoader\";\nimport \"./endpage.css\";\n\nconst SpaceShip = () => {\n  const [model, setModel] = useState();\n\n  console.log(\"Reaching here\");\n  useEffect(() => {\n    new GLTFLoader().load(\"./scene-draco.gltf\", setModel);\n  }, []);\n\n  return model ? <primitive object={model.scene} /> : null;\n};\n\nfunction Loading() {\n  const [finished, set] = useState(false);\n  const [width, setWidth] = useState(0);\n\n  useEffect(() => {\n    THREE.DefaultLoadingManager.onLoad = () => set(true);\n    THREE.DefaultLoadingManager.onProgress = (url, itemsLoaded, itemsTotal) =>\n      setWidth((itemsLoaded / itemsTotal) * 200);\n  });\n\n  const props = useTransition(finished, null, {\n    from: { opacity: 1, width: 0 },\n    leave: { opacity: 0 },\n    update: { width },\n  });\n\n  return props.map(\n    ({ item: finished, key, props: { opacity, width } }) =>\n      !finished && (\n        <a.div className=\"loading\" key={key} style={{ opacity }}>\n          <div className=\"loading-bar-container\">\n            <a.div className=\"loading-bar\" style={{ width }} />\n          </div>\n        </a.div>\n      )\n  );\n}\n\nclass endpage extends Component {\n  state = {};\n\n  render() {\n    const h = window.height;\n\n    return (\n      <>\n        <div className=\"bg\">\n          <h1>\n            TheEnd\n            <br />\n            <span></span>\n          </h1>\n          <Canvas\n            style={{ height: 1050 }}\n            shadowMap\n            camera={{ position: [0, 0, 21] }}\n          >\n            <ambientLight intensity={0.75} />\n            <pointLight intensity={1} position={[-10, -30, -10]} />\n            <spotLight\n              castShadow\n              intensity={2.25}\n              angle={0.2}\n              penumbra={1}\n              position={[25, 25, 25]}\n              shadow-mapSize-width={1024}\n              shadow-mapSize-height={1024}\n              shadow-bias={-0.0001}\n            />\n            <fog attach=\"fog\" args={[\"#cc7b32\", 20, 25]} />\n            <Suspense fallback={null}>\n              <SpaceShip></SpaceShip>\n            </Suspense>\n            <OrbitControls\n              autoRotate\n              enablePan={false}\n              enableZoom={true}\n              enableDamping\n              dampingFactor={0.5}\n              rotateSpeed={1}\n              maxPolarAngle={Math.PI / 2}\n              minPolarAngle={Math.PI / 2}\n            />\n          </Canvas>\n          <div className=\"layer\" />\n          <Loading />\n          <a\n            href=\"https://github.com/HackGod2000/TouchDown.js\"\n            className=\"top-left\"\n            children=\"Github\"\n          />\n\n          <a\n            href=\"https://github.com/drcmda/react-three-fiber\"\n            className=\"top-right\"\n            children=\"+ react-three-fiber\"\n          />\n        </div>\n      </>\n    );\n  }\n}\n\nexport default endpage;\n","import React, { useRef } from \"react\";\nimport { extend, useFrame, useThree } from \"react-three-fiber\";\nimport OrbitControls from \"three-orbitcontrols\";\n\n//Controls teh camera view and orbitControls\n\nextend({ OrbitControls });\n\nfunction Controls() {\n  const controlsRef = useRef();\n  const { camera, gl, size } = useThree();\n\n  useFrame(() => controlsRef.current && controlsRef.current.update());\n\n  return (\n    <orbitControls\n      ref={controlsRef}\n      args={[camera, gl.domElement]}\n      enableRotate\n      enablePan={true}\n    />\n  );\n}\n\nexport default Controls;\n","import React from \"react\";\nimport \"./Model.css\";\n\nfunction Startpage() {\n  return (\n    <div className=\"text-box\">\n      <div className=\"myheading\">WELCOME TO MARS!</div>\n      <div className=\"text-box2\">\n        <li>\n          You can change the <strong>STARTING POSITION</strong> and the{\" \"}\n          <strong>DESTINATION POSITION</strong> by dragging.\n        </li>\n        <li>\n          There will be many hurdles in your way in the form of{\" \"}\n          <strong>WEIGHTED</strong> and <strong>INFINITE WALLS</strong>. You can\n          cross the weighted wall with some penalty.\n        </li>\n        <li>\n          Select one of the walls and click on the grid to place it over there.\n        </li>\n        <li>\n          To help you find your way, we have a bunch of algorithms. You can\n          explore various options under them.\n        </li>\n      </div>\n      <div className=\"text-box3\">\n        To land on Mars, click on <strong>START</strong>!\n      </div>\n      <div className=\"text-box4\">Enjoy your journey!</div>\n    </div>\n  );\n}\n\nexport default Startpage;\n","import React, { Component, useMemo, useRef, useState } from \"react\";\nimport { Canvas, useFrame } from \"react-three-fiber\";\nimport * as THREE from \"three\";\nimport Controls from \"./Controls\";\nimport img1 from \"./images/background.jpg\";\nimport bumperURL from \"./images/marsbump1k.jpg\";\nimport marsURL from \"./images/marsmap1k.jpg\";\nimport \"./Model.css\";\nimport StartPage from \"./Startpage\";\nconsole.log(bumperURL);\n\nclass Model extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      scale: [1, 1, 1],\n    };\n    this.zoom = this.zoom.bind(this);\n    this.enlarge = this.enlarge.bind(this);\n  }\n  componentDidMount() {\n    document.body.style.backgroundImage = `url(${img1})`;\n  }\n  enlarge(i, j, k) {\n    const scaled = parseFloat(`${i}.${j}${k}`, 10);\n    this.setState({ scale: [scaled, scaled, scaled] });\n  }\n  async zoom() {\n    for (let i = 1; i <= 2; i++) {\n      for (let j = 0; j <= 9; j++) {\n        for (let k = 0; k <= 9; k++) {\n          await this.enlarge(i, j, k);\n          await sleep(5);\n        }\n      }\n    }\n  }\n  render() {\n    return (\n      <>\n        <StartPage />\n        <div className=\"button-wrapper\">\n          <div\n            className=\"button\"\n            onClick={async () => {\n              await this.zoom();\n              window.location =\n                \"https://hackgod2000.github.io/TouchDown.js/#/algo\";\n            }}\n          >\n            START\n          </div>\n        </div>\n        <div className=\"canvas-div\">\n          <Canvas camera={{ position: [0, 0, 20] }}>\n            <ambientLight intensity={1.0} />\n            <pointLight intensity={0.9} position={[-10, -25, -10]} />\n            <spotLight\n              castShadow\n              intensity={0.25}\n              angle={Math.PI / 8}\n              position={[25, 25, 15]}\n              shadow-mapSize-width={2048}\n              shadow-mapSize-height={2048}\n            />\n            <Controls />\n            <Mars position={[1.2, 0, 0]} scale={this.state.scale} />\n          </Canvas>\n        </div>\n      </>\n    );\n  }\n}\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nfunction Mars(props) {\n  const mesh = useRef();\n  const [hovered, setHover] = useState(false);\n  const [active, setActive] = useState(false);\n  const imgmars = useMemo(() => new THREE.TextureLoader().load(marsURL), [\n    marsURL,\n  ]);\n  const bumpmap1 = useMemo(() => new THREE.TextureLoader().load(bumperURL), [\n    bumperURL,\n  ]);\n  console.log(marsURL);\n  // Rotate mesh every frame, this is outside of React without overhead\n  useFrame(() => (mesh.current.rotation.y += 0.006));\n  return (\n    <mesh\n      {...props}\n      ref={mesh}\n      scale={props.scale}\n      onClick={(e) => {\n        setActive(!active);\n      }}\n      onPointerOver={(e) => setHover(true)}\n      onPointerOut={(e) => setHover(false)}\n    >\n      <sphereGeometry attach=\"geometry\" args={[6, 26, 26]} />\n      <meshStandardMaterial\n        attach=\"material\"\n        color={hovered ? \"hotpink\" : \"orange\"}\n        map={imgmars}\n        bumpmap={bumpmap1}\n        bumpscale={0.1}\n      />\n    </mesh>\n  );\n}\n\nexport default Model;\n","function isReachable(grid,r,c){\n    if (-1 < r && -1 < c && r < grid.length && c <grid[0].length){\n        if (!grid[r][c].isWall){\n            return true\n        }\n    }\n    return false\n}\nfunction getneighbors(grid,node,diagonalallowed){\n    var neighbors = []; \n    console.log(diagonalallowed)\n    // else{\n    var temp = [[-1,0],[0,-1],[0,1],[1,0]]\n    // }\n    if (diagonalallowed){\n        temp.push([-1,-1])\n        temp.push([1,-1])\n        temp.push([1,1])\n        temp.push([-1,1])\n    }\n    for (var i = 0 ; i< temp.length ; i++){\n        var r = node.row+temp[i][0]\n        var c = node.col+temp[i][1]\n        if (isReachable(grid,r,c)){\n            neighbors.push(grid[r][c])\n        }\n    }\n    return neighbors\n}\nfunction heuristic(a,b){\n    return Math.sqrt((b.row - a.row) ** 2 + (b.col - a.col) ** 2)\n}\nvar Heap = require('heap');\nexport function Astar(grid,startNode,finishNode,h,diagonalallowed){\n    console.log(diagonalallowed)\n    var openList = new Heap(function(nodeA, nodeB) {return nodeA.fscore - nodeB.fscore})\n    startNode.gscore = 0 ;\n    startNode.fscore = 0 ; \n    openList.push(startNode);\n    startNode.inopen = true;\n    const visitedNodesInOrder = [];\n    while (!openList.empty()) {\n        var node = openList.pop();\n        node.inclosed = true;\n        visitedNodesInOrder.push(node)\n        if (node === finishNode){\n            return visitedNodesInOrder;\n        }\n        // console.log(\"ji\")\n        var neighbors = getneighbors(grid,node,diagonalallowed)\n        for (var i = 0; i<neighbors.length;i++){\n            var neighbor = neighbors[i];\n            if (!neighbor.inclosed) {\n                var r = neighbor.row; var c = neighbor.col ;\n                var ng = node.gscore + Math.sqrt((neighbor.row - node.row) ** 2 + (neighbor.col - node.col) ** 2)\n                if (!neighbor.inopen || ng < neighbor.gscore) {\n                    neighbor.gscore = ng;\n                    neighbor.hscore = heuristic(neighbor,finishNode);\n                    neighbor.fscore = neighbor.gscore + neighbor.hscore;\n                    neighbor.previousNode = node;\n\n                    if (!neighbor.inopen) {\n                        openList.push(neighbor);\n                        neighbor.inopen = true;\n                    } else {\n                        openList.updateItem(neighbor);\n                    }\n                }\n            }\n        }\n    }\n    return visitedNodesInOrder\n}\n\n","//This is my variation of BEST FIRST SEARCH\nexport function Bestfs(grid, startNode, finishNode,heuristic,diagonalallowed) {\n    const visitedNodesInOrder = []; //closed list\n    startNode.distance = 0;\n    const unvisitedNodes = getAllNodes(grid); //open list\n    //Till unvisited ndoes is empty we run the while loop\n    while (unvisitedNodes.length>0) {\n      //Sorting the unvisited Nodes by length\n      sortNodesByDistance(unvisitedNodes);\n      const closestNode = unvisitedNodes.shift();\n      // If we encounter a wall, we skip it.\n      if (closestNode.isWall && closestNode.wallweight==99999999) continue;\n      // If the closest node is at a distance of infinity,\n      // we must be trapped and should therefore stop.\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\n      closestNode.isVisited = true;\n      visitedNodesInOrder.push(closestNode);\n      //If closesnode is the end node we return visitedNodesInorder\n      if (closestNode === finishNode) return visitedNodesInOrder;\n      updateUnvisitedNeighbors(closestNode, grid,finishNode,heuristic,diagonalallowed,closestNode.wallweight);\n    }\n  }\n  function sortNodesByDistance(unvisitedNodes) {\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n  }\n  //update the heuristic of the unvisited neighbors\n  function updateUnvisitedNeighbors(node, grid,finishNode,heuristic,diagonalallowed,wallweight) {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid,diagonalallowed);\n    for (const neighbor of unvisitedNeighbors) {\n      //value variable will store the heuristic distance of the node\n      var value;\n      var string=\"Manhattan\";\n      var string2=\"Diagonal\";\n      var string3=\"Euclidean\";\n      var string4=\"Octile\";\n      var string5=\"Chebyshev\";\n      if(heuristic.localeCompare(string)==0)\n      {\n        value=Math.abs(neighbor.row-finishNode.row)+Math.abs(neighbor.col-finishNode.col);\n        \n      }\n      else if(heuristic.localeCompare(string2)==0)\n      {\n        value=Math.max(Math.abs(neighbor.row-finishNode.row),Math.abs(neighbor.col-finishNode.col));\n       \n      }\n      else if(heuristic.localeCompare(string3)==0)\n      {\n        value=Math.sqrt(Math.pow((neighbor.row-finishNode.row),2)+Math.pow((neighbor.col-finishNode.col),2));\n      \n      }\n      else if(heuristic.localeCompare(string4)==0)\n      {\n        var x_dist=Math.abs(neighbor.row-finishNode.row);\n        var y_dist=Math.abs(neighbor.col-finishNode.col);\n        value=Math.max(x_dist,y_dist)+(Math.sqrt(2)-1) * Math.min(x_dist,y_dist);\n        \n      }\n      else if(heuristic.localeCompare(string5)==0)\n      {\n        value=Math.max(Math.abs(neighbor.row-finishNode.row),Math.abs(neighbor.col-finishNode.col));\n        \n      }\n      //making the neighbor distance as heuristic distance.If the neighbor node is a weighted wall then a penalty is added to the heuristic distance\n      neighbor.distance=value*wallweight;\n      neighbor.previousNode = node; // making the node as previous Node of neighbor\n      neighbor.isVisited=true;\n      //adjusting the visited state and previousNode of the neighbor\n    }\n  }\n  //retruns all unvisited neighbors\n  function getUnvisitedNeighbors(node, grid,diagonalallowed) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    if (diagonalallowed){\n      if (row > 0 && col > 0) neighbors.push(grid[row-1][col-1]);\n      if (row > 0 && col < grid[0].length - 1) neighbors.push(grid[row-1][col+1]);\n      if (row <  grid.length - 1 && col > 0 ) neighbors.push(grid[row+1][col-1]);\n      if (row <  grid.length - 1 && col < grid[0].length - 1) neighbors.push(grid[row+1][col+1]);\n      \n    }\n    //filtering the neighbors\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n  }\n  //Returns all nodes\n  function getAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n      for (const node of row) {\n        nodes.push(node);\n      }\n    }\n    return nodes;\n  }\n  \n  ","export function bfs(grid,startNode,finishNode,diagonalallowed){\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const queue = [startNode];\n  while (!!queue.length){\n    const closestNode = queue.shift();\n    if (closestNode.isWall) continue ;\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    const unvisitedNeighbors = getUnvisitedNeighbors(closestNode, grid,diagonalallowed);\n    for (const neighbor of unvisitedNeighbors){\n      neighbor.previousNode = closestNode;\n      neighbor.isVisited = true;\n      neighbor.distance = closestNode.distance + 1;\n      queue.push(neighbor);\n    }\n\n  }\n}\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid,diagonalallowed) {\n  const neighbors = [];\n  const {col, row} = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  if (diagonalallowed){\n    if (row > 0 && col > 0) neighbors.push(grid[row-1][col-1]);\n    if (row > 0 && col < grid[0].length - 1) neighbors.push(grid[row-1][col+1]);\n    if (row <  grid.length - 1 && col > 0 ) neighbors.push(grid[row+1][col-1]);\n    if (row <  grid.length - 1 && col < grid[0].length - 1) neighbors.push(grid[row+1][col+1]);\n    \n  }\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\n//Implementation of Bi-directional search in Dijkstra algorithm\nimport _ from \"lodash\" ;\nexport function bidijkstra(grid,startNode,finishNode,diagonalallowed){\n    const visitedNodesInOrder = []; //maintains the nodes to be visualised\n    const TempEnd=[]; //maintains the list from end node till interscetion node\n    const TempStart=[];//maintains the list from start node till intersection node\n    const tempstart = _.cloneDeep(startNode);\n    tempstart.distance=0;\n    const tempend = _.cloneDeep(finishNode);\n    tempend.distance=0;\n    TempStart.push(tempstart);\n    TempEnd.push(tempend);\n    while (TempStart.length>0 && TempEnd.length>0){\n      //putting the smallest node from TempStart in visitedNodesinOrder\n        sortNodesByDistance(TempStart);\n      const closestNode = TempStart.shift();\n      if (closestNode.isWall && closestNode.wallweight==999999) continue ;\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\n      closestNode.startvisited = true;\n      const unvisitedNeighbors = getUnvisitedNeighbors(closestNode, grid,diagonalallowed);\n      for (const neighbor of unvisitedNeighbors){\n        if (neighbor.startvisited) continue ;\n        neighbor.previousNode = closestNode;\n          neighbor.startvisited = true;\n          neighbor.distance = closestNode.distance + closestNode.wallweight;\n          TempStart.push(neighbor);\n      }\n      visitedNodesInOrder.push(closestNode);\n      //if we reach the finish node from start side\n      if (closestNode === finishNode) {\n        var temp1 = [closestNode];\n        visitedNodesInOrder.unshift(temp1)\n        return visitedNodesInOrder;\n      }\n      //if we reach the intersecting nodes\n      if (closestNode.endvisited){\n        var temp2 = [closestNode];\n        visitedNodesInOrder.unshift(temp2)\n        return visitedNodesInOrder;\n      }\n      //after putting the shortest distance node from Tempstart then we will put a node from TempEnd in visitedNodesInOrder\n      sortNodesByDistance(TempEnd);\n      const closestNodeEnd = TempEnd.shift();\n      if (closestNodeEnd.isWall && closestNodeEnd.wallweight==999999) continue ;\n      if (closestNodeEnd.distance === Infinity) return visitedNodesInOrder;\n      closestNodeEnd.endvisited = true;\n      const unvisitedNeighbors2 = getUnvisitedNeighbors(closestNodeEnd, grid,diagonalallowed);\n      for (const neighbor of unvisitedNeighbors2){\n        if (neighbor.endvisited) continue ;\n         neighbor.next=closestNodeEnd; \n         // neighbor.previousNode = closestNodeEnd;\n          neighbor.endvisited = true;\n          neighbor.distance = closestNodeEnd.distance + closestNodeEnd.wallweight;\n          TempEnd.push(neighbor);\n          // console.log(\"Neighbor updation\");\n      }\n      visitedNodesInOrder.push(closestNodeEnd);\n      //if we reach the startnode from end side\n      if (closestNodeEnd === startNode) {\n          //console.log(\"Reached End\");\n        var temp1 = [closestNodeEnd];\n        visitedNodesInOrder.unshift(temp1)\n        return visitedNodesInOrder;\n      }\n      //if we find the intersecting nodes\n      if (closestNodeEnd.startvisited){\n          //console.log(\"Hurrayyyy!!!\");\n        var temp2 = [closestNodeEnd];\n        visitedNodesInOrder.unshift(temp2)\n        return visitedNodesInOrder;\n      }\n      \n      \n    }\n    //if nodes in TempStart are left to be visualised\n    while ( TempStart.length>0){\n        // console.log(\"Start side left\");\n        sortNodesByDistance(TempStart);\n      const closestNode = TempStart.shift();\n      if (closestNode.isWall && closestNode.wallweight==999999) continue ;\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\n      closestNode.startvisited = true;\n      const unvisitedNeighbors = getUnvisitedNeighbors(closestNode, grid,diagonalallowed);\n      for (const neighbor of unvisitedNeighbors){\n        if (neighbor.startvisited) continue ;\n         neighbor.previousNode = closestNode;\n          neighbor.startvisited = true;\n          neighbor.distance = closestNode.distance + closestNode.wallweight;\n          TempStart.push(neighbor);\n      }\n      visitedNodesInOrder.push(closestNode);\n      if (closestNode === finishNode) {\n        var temp1 = [closestNode];\n        visitedNodesInOrder.unshift(temp1)\n        return visitedNodesInOrder;\n      }\n      if (closestNode.endvisited){\n        var temp2 = [closestNode];\n        visitedNodesInOrder.unshift(temp2)\n        return visitedNodesInOrder;\n      }\n\n      \n    }\n    //if nodes in tempend are left to be visualised\n    while (TempEnd.length>0){\n        // console.log(\"End side left\");\n      sortNodesByDistance(TempEnd);\n      const closestNodeEnd = TempEnd.shift();\n      if (closestNodeEnd.isWall && closestNodeEnd.wallweight==999999) continue ;\n      if (closestNodeEnd.distance === Infinity) return visitedNodesInOrder;\n      closestNodeEnd.endvisited = true;\n      const unvisitedNeighbors2 = getUnvisitedNeighbors(closestNodeEnd, grid,diagonalallowed);\n      for (const neighbor of unvisitedNeighbors2){\n        if (neighbor.endvisited) continue ;\n        neighbor.next=closestNodeEnd;\n          neighbor.endvisited = true;\n          neighbor.distance = closestNodeEnd.distance + closestNodeEnd.wallweight;\n          TempEnd.push(neighbor);\n      }\n      visitedNodesInOrder.push(closestNodeEnd);\n      if (closestNodeEnd === startNode) {\n        var temp1 = [closestNodeEnd];\n        visitedNodesInOrder.unshift(temp1)\n        return visitedNodesInOrder;\n      }\n      if (closestNodeEnd.startvisited){\n        var temp2 = [closestNodeEnd];\n        visitedNodesInOrder.unshift(temp2)\n        return visitedNodesInOrder;\n      }\n      \n    }\n  }\n  //sorts the node by distance parameter\n  function sortNodesByDistance(unvisitedNodes) {\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n  }\n  \n  //Get all neighbors\n  function getUnvisitedNeighbors(node, grid,diagonalallowed) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    if (diagonalallowed){\n        if (row > 0 && col > 0) neighbors.push(grid[row-1][col-1]);\n        if (row > 0 && col < grid[0].length - 1) neighbors.push(grid[row-1][col+1]);\n        if (row <  grid.length - 1 && col > 0 ) neighbors.push(grid[row+1][col-1]);\n        if (row <  grid.length - 1 && col < grid[0].length - 1) neighbors.push(grid[row+1][col+1]);\n    }\n    return neighbors\n  }\n  \n  \n  \n  // Backtracks from the finishNode to find the shortest path.\n  // Only works when called after the bi-dijkstra method above.\n  export function getNodesInShortestPathOrder(finishNode) {\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n  }\n  //This function finds the shortest path in bi-directional search.It starts visualisaing the shortest path from both start node and end node side and at the end visualises the intersecting node.\n  export function bidfsans(node) {\n    //Here node is the intersecting node which is the only node having both previousNode and next\n    // return [node];\n    //console.log(node);\n    var ans = [];\n    let s = node;   //To traverse the start side\n    let e = node;   //To traverse the end side\n    // console.log(s);\n    // console.log(e);\n    while (s.previousNode !== null && e.next!== null){\n      ans.unshift(s.previousNode);\n      ans.unshift(e.next);\n      s = s.previousNode;\n      e = e.next ;\n    }\n    //if the nodes from start side are left\n    while (s.previousNode !== null){\n        // console.log(\"Wohooo\");\n      ans.unshift(s.previousNode);\n      s = s.previousNode;\n    }\n    //if nodes from end side are left\n    while (e.next !== null){\n      ans.unshift(e.next);\n      e = e.next ;\n    }\n    ans.push(node)\n    return ans\n  }\n  ","// function isReachable(grid,r,c){\n//     if (-1 < r && -1 < c && r < grid.length && c <grid[0].length){\n//         if (!grid[r][c].isWall){\n//             return true\n//         }\n//     }\n//     return false\n// }\n// function heuristic(a,b,h){\n//     if (h === 1){\n//         // Euclidean\n//        return Math.sqrt((b.row - a.row) ** 2 + (b.col - a.col) ** 2)\n//     }\n//     if (h === 2){\n//         // Manhattan\n//         return b.row - a.row + b.col - a.col\n//     }\n//     if (h === 3){\n//         // octile\n//         var a = Math.sqrt(2) - 1\n//         var dx = b.row - a.row\n//         var dy = b.col - a.col\n//         return dx + dy + (a- 2)*Math.min(dx,dy)\n\n//     }\n//     if (h === 4){\n//         // chebyshev\n//         var dx = b.row - a.row\n//         var dy = b.col - a.col\n//         return Math.max(dx,dy)\n//     }\n// }\n// var Heap = require('heap');\n// export function BiAstar(grid,startNode,finishNode,h){\n//     // console.log(startNode)\n//     var startopenList = new Heap(function(nodeA, nodeB) {return nodeA.fscore - nodeB.fscore})\n\n//     var endopenList = new Heap(function(nodeA, nodeB) {return nodeA.fscore - nodeB.fscore})\n//     startNode.gscore = 0 ; finishNode.gscore = 0\n//     startNode.fscore = 0 ; finishNode.fscore = 0\n//     startopenList.push(startNode); endopenList.push(finishNode)\n//     startNode.inopen = true; finishNode.inopen = true\n//     const visitedNodesInOrder = [];\n//     while (!startopenList.empty() && !endopenList.empty()) {\n//         var node = startopenList.pop();\n//         node.inclosed = true;\n//         node.startvisited = true\n//         visitedNodesInOrder.push(node)\n//         if (node === finishNode){\n//             var temp1 = [node];\n//             console.log(1)\n//             visitedNodesInOrder.unshift(temp1)\n//             return visitedNodesInOrder;\n//         }\n//         var neighbors = getneighbors(grid,node)\n//         for (var i = 0; i<neighbors.length;i++){\n//             var neighbor = neighbors[i];\n//             if (neighbor.endvisited){\n//                 neighbor.previousNode = node\n//                 var temp2 = [neighbor];\n//                 console.log(2)\n//                 visitedNodesInOrder.unshift(temp2)\n//                 return visitedNodesInOrder;\n//             }\n//             if (!neighbor.inclosed) {\n//                 var r = neighbor.row; var c = neighbor.col ;\n//                 var ng = node.gscore + Math.sqrt((neighbor.row - node.row) ** 2 + (neighbor.col - node.col) ** 2)\n//                 if (!neighbor.inopen || ng < neighbor.gscore) {\n//                     neighbor.gscore = ng;\n//                     neighbor.hscore = heuristic(neighbor,finishNode,h);\n//                     neighbor.fscore = neighbor.gscore + neighbor.hscore;\n//                     neighbor.previousNode = node;\n\n//                     if (neighbor.endvisited){\n//                         var temp3 = [neighbor];\n//                         console.log(3)\n//                         visitedNodesInOrder.unshift(temp3)\n\n//                         return visitedNodesInOrder;\n//                     }\n//                     if (!neighbor.inopen) {\n//                         startopenList.push(neighbor);\n//                         neighbor.startvisited = true\n//                         neighbor.inopen = true;\n//                     } else {\n//                         startopenList.updateItem(neighbor);\n//                         neighbor.startvisited = true\n//                     }\n//                 }\n//             }\n//         }\n\n//         var enode = endopenList.pop();\n//         enode.inclosed = true;\n//         enode.endvisited = true\n//         visitedNodesInOrder.push(enode)\n//         if (enode === startNode){\n//             var temp4 = [enode];\n\n//             console.log(4)\n//             visitedNodesInOrder.unshift(temp4)\n//             return visitedNodesInOrder;\n//         }\n//         var eneighbors = getneighbors(grid,enode)\n//         for (var i = 0; i<eneighbors.length;i++){\n//             var eneighbor = eneighbors[i];\n//             if (eneighbor.startvisited){\n//                 var temp5 = [eneighbor];\n//                 eneighbor.nex = enode\n//                 console.log(5)\n//                 visitedNodesInOrder.unshift(temp5)\n//                 return visitedNodesInOrder;\n//             }\n//             if (!eneighbor.inclosed) {\n//                 var r = eneighbor.row; var c = eneighbor.col ;\n//                 var ng = enode.gscore + Math.sqrt((eneighbor.row - enode.row) ** 2 + (eneighbor.col - enode.col) ** 2)\n//                 if (!eneighbor.inopen || ng < eneighbor.gscore) {\n//                     eneighbor.gscore = ng;\n//                     eneighbor.hscore = heuristic(eneighbor,startNode,h);\n//                     eneighbor.fscore = eneighbor.gscore + eneighbor.hscore;\n//                     eneighbor.nex = enode;\n\n//                     if (eneighbor.startvisited){\n//                         var temp6 = [eneighbor];\n//                         console.log(6)\n//                         visitedNodesInOrder.unshift(temp6)\n\n//                         return visitedNodesInOrder;\n//                     }\n//                     if (!eneighbor.inopen) {\n//                         endopenList.push(eneighbor);\n//                         eneighbor.endvisited = true\n//                         eneighbor.inopen = true;\n//                     } else {\n//                         startopenList.updateItem(neighbor);\n//                         eneighbor.endvisited = true\n\n//                     }\n//                 }\n//             }\n//         }\n\n//     }\n//     return visitedNodesInOrder\n// }\n\nfunction isReachable(grid, r, c) {\n  if (-1 < r && -1 < c && r < grid.length && c < grid[0].length) {\n    if (!grid[r][c].isWall) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction getneighbors(grid, node, diagonalallowed) {\n  var neighbors = [];\n  console.log(diagonalallowed);\n  // else{\n  var temp = [\n    [-1, 0],\n    [0, -1],\n    [0, 1],\n    [1, 0],\n  ];\n  // }\n  if (diagonalallowed) {\n    temp.push([-1, -1]);\n    temp.push([1, -1]);\n    temp.push([1, 1]);\n    temp.push([-1, 1]);\n  }\n  for (var i = 0; i < temp.length; i++) {\n    var r = node.row + temp[i][0];\n    var c = node.col + temp[i][1];\n    if (isReachable(grid, r, c)) {\n      neighbors.push(grid[r][c]);\n    }\n  }\n  return neighbors;\n}\nfunction heuristic(a, b) {\n  return Math.sqrt((b.row - a.row) ** 2 + (b.col - a.col) ** 2);\n}\nvar Heap = require(\"heap\");\n\nexport function BiAstar(grid, startNode, finishNode, h, diagonalallowed) {\n  // console.log(startNode)\n  var startopenList = new Heap(function (nodeA, nodeB) {\n    return nodeA.fscore - nodeB.fscore;\n  });\n\n  var endopenList = new Heap(function (nodeA, nodeB) {\n    return nodeA.fscore - nodeB.fscore;\n  });\n  startNode.gscore = 0;\n  finishNode.gscore = 0;\n  startNode.fscore = 0;\n  finishNode.fscore = 0;\n  startopenList.push(startNode);\n  endopenList.push(finishNode);\n  startNode.inopen = true;\n  finishNode.inopen = true;\n  const visitedNodesInOrder = [];\n  while (!startopenList.empty() && !endopenList.empty()) {\n    var node = startopenList.pop();\n    node.inclosed = true;\n    node.startvisited = true;\n    visitedNodesInOrder.push(node);\n    if (node === finishNode) {\n      var temp1 = [node];\n      console.log(1);\n      visitedNodesInOrder.unshift(temp1);\n      return visitedNodesInOrder;\n    }\n    var neighbors = getneighbors(grid, node, diagonalallowed);\n    for (var i = 0; i < neighbors.length; i++) {\n      var neighbor = neighbors[i];\n      if (neighbor.endvisited) {\n        neighbor.previousNode = node;\n        var temp2 = [neighbor];\n        console.log(2);\n        visitedNodesInOrder.unshift(temp2);\n        return visitedNodesInOrder;\n      }\n      if (!neighbor.inclosed) {\n        var r = neighbor.row;\n        var c = neighbor.col;\n        var ng =\n          node.gscore +\n          Math.sqrt(\n            (neighbor.row - node.row) ** 2 + (neighbor.col - node.col) ** 2\n          );\n        if (!neighbor.inopen || ng < neighbor.gscore) {\n          neighbor.gscore = ng;\n          neighbor.hscore = heuristic(neighbor, finishNode, h);\n          neighbor.fscore = neighbor.gscore + neighbor.hscore;\n          neighbor.previousNode = node;\n\n          if (neighbor.endvisited) {\n            var temp3 = [neighbor];\n            console.log(3);\n            visitedNodesInOrder.unshift(temp3);\n\n            return visitedNodesInOrder;\n          }\n          if (!neighbor.inopen) {\n            startopenList.push(neighbor);\n            neighbor.startvisited = true;\n            neighbor.inopen = true;\n          } else {\n            startopenList.updateItem(neighbor);\n            neighbor.startvisited = true;\n          }\n        }\n      }\n    }\n\n    var enode = endopenList.pop();\n    enode.inclosed = true;\n    enode.endvisited = true;\n    visitedNodesInOrder.push(enode);\n    if (enode === startNode) {\n      var temp4 = [enode];\n\n      console.log(4);\n      visitedNodesInOrder.unshift(temp4);\n      return visitedNodesInOrder;\n    }\n    var eneighbors = getneighbors(grid, enode, diagonalallowed);\n    for (var i = 0; i < eneighbors.length; i++) {\n      var eneighbor = eneighbors[i];\n      if (eneighbor.startvisited) {\n        var temp5 = [eneighbor];\n        eneighbor.nex = enode;\n        console.log(5);\n        visitedNodesInOrder.unshift(temp5);\n        return visitedNodesInOrder;\n      }\n      if (!eneighbor.inclosed) {\n        var r = eneighbor.row;\n        var c = eneighbor.col;\n        var ng =\n          enode.gscore +\n          Math.sqrt(\n            (eneighbor.row - enode.row) ** 2 + (eneighbor.col - enode.col) ** 2\n          );\n        if (!eneighbor.inopen || ng < eneighbor.gscore) {\n          eneighbor.gscore = ng;\n          eneighbor.hscore = heuristic(eneighbor, startNode, h);\n          eneighbor.fscore = eneighbor.gscore + eneighbor.hscore;\n          eneighbor.nex = enode;\n\n          if (eneighbor.startvisited) {\n            var temp6 = [eneighbor];\n            console.log(6);\n            visitedNodesInOrder.unshift(temp6);\n\n            return visitedNodesInOrder;\n          }\n          if (!eneighbor.inopen) {\n            endopenList.push(eneighbor);\n            eneighbor.endvisited = true;\n            eneighbor.inopen = true;\n          } else {\n            startopenList.updateItem(neighbor);\n            eneighbor.endvisited = true;\n          }\n        }\n      }\n    }\n  }\n  return visitedNodesInOrder;\n}\n","import _ from \"lodash\" ;\n//Implementation of Bidirectional Best First Search\nexport function BiBestfs(grid, startNode, finishNode,heuristic,diagonalallowed) {\n  const visitedNodesInOrder = []; //closed list\n  const TempEnd=[]; //Put all nodes from end node till intersecting nodes in it\n    const TempStart=[]; //Put all nodes from start node till intersecting nodes in it\n    const tempstart = _.cloneDeep(startNode); //cloning the start node\n    tempstart.distance=0;\n    const tempend = _.cloneDeep(finishNode);//cloing the finish node\n    tempend.distance=0;\n    TempStart.push(tempstart);\n    TempEnd.push(tempend);\n  while (TempStart.length>0 && TempEnd.length>0) {\n    sortNodesByDistance(TempStart);\n    const closestNode = TempStart.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall && closestNode.wallweight==99999999) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.startvisited = true;\n    visitedNodesInOrder.push(closestNode);\n    updateUnvisitedNeighborsStart(closestNode, grid,finishNode,heuristic,diagonalallowed,TempStart,closestNode.wallweight);\n    if (closestNode === finishNode) \n    {\n      //console.log(\"Hello\");\n        var temp1 = [closestNode];\n        visitedNodesInOrder.unshift(temp1)\n        return visitedNodesInOrder;\n    }\n    if (closestNode.endvisited){\n      // console.log(\"Hi\");\n    var temp2 = [closestNode];\n    visitedNodesInOrder.unshift(temp2)\n    return visitedNodesInOrder;\n  }\n    //Sorting the TempEnd to extract the node with shortest distance\n    sortNodesByDistance(TempEnd);\n    const closestNode2 = TempEnd.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode2.isWall && closestNode2.wallweight==99999999) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode2.distance === Infinity) return visitedNodesInOrder;\n    closestNode2.endvisited = true;\n    updateUnvisitedNeighborsEnd(closestNode2, grid,finishNode,heuristic,diagonalallowed,TempEnd,closestNode2.wallweight);\n    visitedNodesInOrder.push(closestNode2);\n    if (closestNode2 === startNode) \n    {\n      //console.log(\"Hello\");\n        var temp1 = [closestNode2];\n        visitedNodesInOrder.unshift(temp1)\n        return visitedNodesInOrder;\n    }\n    if (closestNode2.startvisited){\n      //console.log(\"Hurrayyyy!!!\");\n    var temp2 = [closestNode2];\n    visitedNodesInOrder.unshift(temp2)\n    return visitedNodesInOrder;\n    }\n   \n  }\n  //If nodes in TempStart are left to be visualised\n  while ( TempStart.length>0){\n    // console.log(\"Start side left\");\n    sortNodesByDistance(TempStart);\n    const closestNode = TempStart.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall && closestNode.wallweight==99999999) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.startvisited = true;\n    updateUnvisitedNeighborsStart(closestNode, grid,finishNode,heuristic,diagonalallowed,TempStart,closestNode.wallweight);\n    visitedNodesInOrder.push(closestNode);\n    //if we reach the finishnode from starting point in bi-direction search\n    if (closestNode === finishNode) \n    {\n      //console.log(\"Hello\");\n        var temp1 = [closestNode];\n        visitedNodesInOrder.unshift(temp1)\n        return visitedNodesInOrder;\n    }\n    //if the intersecting node is found\n    if (closestNode.endvisited){\n      // console.log(\"Hi\");\n    var temp2 = [closestNode];\n    visitedNodesInOrder.unshift(temp2)\n    return visitedNodesInOrder;\n    }\n     \n  }\n  //If nodes in TempEnd are left to be visualised\n  while (TempEnd.length>0){\n    // console.log(\"End side left\");\n    sortNodesByDistance(TempEnd);\n    const closestNode2 = TempEnd.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode2.isWall && closestNode2.wallweight==99999999) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode2.distance === Infinity) return visitedNodesInOrder;\n    closestNode2.endvisited = true;\n    updateUnvisitedNeighborsEnd(closestNode2, grid,finishNode,heuristic,diagonalallowed,TempEnd,closestNode2.wallweight);\n    visitedNodesInOrder.push(closestNode2);\n    //if the the shortest distance from end side reaches the start side\n    if (closestNode2 === startNode) \n    {\n      //console.log(\"Hello\");\n        var temp1 = [closestNode2];\n        visitedNodesInOrder.unshift(temp1)\n        return visitedNodesInOrder;\n    }\n    //if intersecting node is found\n    if (closestNode2.startvisited){\n      //console.log(\"Hurrayyyy!!!\");\n    var temp2 = [closestNode2];\n    visitedNodesInOrder.unshift(temp2)\n    return visitedNodesInOrder;\n    }\n\n  }\n}\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n//to update the heuristic distanc of unvisited neighbors\nfunction updateUnvisitedNeighborsEnd(node, grid,finishNode,heuristic,diagonalallowed,TempEnd,wallweight) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid,diagonalallowed);\n  for (const neighbor of unvisitedNeighbors) {\n    if (neighbor.endvisited) continue ;\n    //console.log(finishNode.col);\n    //console.log(neighbor.col);\n    var value;\n    var string=\"Manhattan\";\n    var string2=\"Diagonal\";\n    var string3=\"Euclidean\";\n    var string4=\"Octile\";\n    var string5=\"Chebyshev\";\n    if(heuristic.localeCompare(string)==0)\n    {\n      value=Math.abs(neighbor.row-finishNode.row)+Math.abs(neighbor.col-finishNode.col);\n    }\n    else if(heuristic.localeCompare(string2)==0)\n    {\n      value=Math.max(Math.abs(neighbor.row-finishNode.row),Math.abs(neighbor.col-finishNode.col));\n     \n    }\n    else if(heuristic.localeCompare(string3)==0)\n    {\n      value=Math.sqrt(Math.pow((neighbor.row-finishNode.row),2)+Math.pow((neighbor.col-finishNode.col),2));\n      \n    }\n    else if(heuristic.localeCompare(string4)==0)\n    {\n      var x_dist=Math.abs(neighbor.row-finishNode.row);\n      var y_dist=Math.abs(neighbor.col-finishNode.col);\n      value=Math.max(x_dist,y_dist)+(Math.sqrt(2)-1) * Math.min(x_dist,y_dist);\n    }\n    else if(heuristic.localeCompare(string5)==0)\n    {\n      value=Math.max(Math.abs(neighbor.row-finishNode.row),Math.abs(neighbor.col-finishNode.col));\n    }\n    neighbor.next=node; \n    // neighbor.previousNode = closestNodeEnd;\n     neighbor.endvisited = true;\n     neighbor.distance = value+wallweight;\n     TempEnd.push(neighbor);\n  }\n}\n//Update the heuristic distance of unvisited neighbors \nfunction updateUnvisitedNeighborsStart(node, grid,finishNode,heuristic,diagonalallowed,TempStart,wallweight) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid,diagonalallowed);\n  for (const neighbor of unvisitedNeighbors) {\n    if (neighbor.startvisited) continue ;\n    var value; //value variable will store the heuristic distance\n    var string=\"Manhattan\";\n    var string2=\"Diagonal\";\n    var string3=\"Euclidean\";\n    var string4=\"Octile\";\n    var string5=\"Chebyshev\";\n    if(heuristic.localeCompare(string)==0)\n    {\n      value=Math.abs(neighbor.row-finishNode.row)+Math.abs(neighbor.col-finishNode.col);\n      \n    }\n    else if(heuristic.localeCompare(string2)==0)\n    {\n      value=Math.max(Math.abs(neighbor.row-finishNode.row),Math.abs(neighbor.col-finishNode.col));\n      \n    }\n    else if(heuristic.localeCompare(string3)==0)\n    {\n      value=Math.sqrt(Math.pow((neighbor.row-finishNode.row),2)+Math.pow((neighbor.col-finishNode.col),2));\n      \n    }\n    else if(heuristic.localeCompare(string4)==0)\n    {\n      var x_dist=Math.abs(neighbor.row-finishNode.row);\n      var y_dist=Math.abs(neighbor.col-finishNode.col);\n      value=Math.max(x_dist,y_dist)+(Math.sqrt(2)-1) * Math.min(x_dist,y_dist);\n     \n    }\n    else if(heuristic.localeCompare(string5)==0)\n    {\n      value=Math.max(Math.abs(neighbor.row-finishNode.row),Math.abs(neighbor.col-finishNode.col));\n      \n    }\n    neighbor.previousNode = node; //making the node as previous node of neighbor\n          neighbor.startvisited = true; //neighbor is visited from start side\n          neighbor.distance = value+wallweight; //if neighbor is a weighted wall then its distance is heuristic+wall weight\n          TempStart.push(neighbor); \n  }\n}\n//To get all neighbors of a node\nfunction getUnvisitedNeighbors(node, grid,diagonalallowed) {\n  const neighbors = [];\n  const {col, row} = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  if (diagonalallowed){\n    if (row > 0 && col > 0) neighbors.push(grid[row-1][col-1]);\n    if (row > 0 && col < grid[0].length - 1) neighbors.push(grid[row-1][col+1]);\n    if (row <  grid.length - 1 && col > 0 ) neighbors.push(grid[row+1][col-1]);\n    if (row <  grid.length - 1 && col < grid[0].length - 1) neighbors.push(grid[row+1][col+1]);\n    \n  }\n  return neighbors;\n}\n\n","export function bbfs(grid,startNode,finishNode,diagonalallowed){\n  const visitedNodesInOrder = [];\n  startNode.distance = 0; finishNode.distance = 0\n  const startqueue = [startNode];\n  startNode.startvisited = true;\n  finishNode.endvisited = true;\n  const endqueue = [finishNode];\n  while (!!startqueue.length && endqueue.length){\n    const closestNode = startqueue.shift();\n    if (closestNode.isWall) continue ;\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) {\n      var temp1 = [closestNode];\n      visitedNodesInOrder.unshift(temp1)\n      return visitedNodesInOrder;\n    }\n    if (closestNode.endvisited){\n      var temp2 = [closestNode];\n      visitedNodesInOrder.unshift(temp2)\n      return visitedNodesInOrder;\n    }\n    const unvisitedNeighbors = getUnvisitedNeighbors(closestNode, grid,diagonalallowed);\n    for (const neighbor of unvisitedNeighbors){\n      if (neighbor.startvisited) continue ;\n      if (neighbor.endvisited){\n        var temp3 = [neighbor];\n      neighbor.previousNode = closestNode;\n        neighbor.startvisited = true;\n        neighbor.distance = closestNode.distance + 1;\n        startqueue.push(neighbor);\n      visitedNodesInOrder.unshift(temp3)\n      return visitedNodesInOrder;\n      }\n        neighbor.previousNode = closestNode;\n        neighbor.startvisited = true;\n        neighbor.distance = closestNode.distance + 1;\n        startqueue.push(neighbor);\n    }\n\n    const ftNode = endqueue.shift();\n    if (ftNode.isWall) continue ;\n    if (ftNode.distance === Infinity) return visitedNodesInOrder;\n    ftNode.isVisited = true;\n    visitedNodesInOrder.push(ftNode);\n    if (ftNode === startNode) {\n      var temp4 = [ftNode];\n      visitedNodesInOrder.unshift(temp4)\n      return visitedNodesInOrder;\n    }\n    if (ftNode.startvisited){\n      var temp5 = [ftNode];\n      visitedNodesInOrder.unshift(temp5)\n      return visitedNodesInOrder;\n    }\n    const unvisitedNeighbor = getUnvisitedNeighbors(ftNode, grid,diagonalallowed);\n    for (const neighbora of unvisitedNeighbor){\n      if (neighbora.endvisited) continue ;\n      if (neighbora.startvisited){\n      var temp6 = [neighbora];\n      visitedNodesInOrder.unshift(temp6)\n      neighbora.nex = ftNode;\n      neighbora.endvisited = true;\n      neighbora.distance = ftNode.distance + 1;\n      endqueue.push(neighbora);\n      return visitedNodesInOrder;\n    }\n      neighbora.nex = ftNode;\n      neighbora.endvisited = true;\n      neighbora.distance = ftNode.distance + 1;\n      endqueue.push(neighbora);\n    }\n  }\n  var temp = [finishNode]\n  visitedNodesInOrder.unshift(temp)\n  return visitedNodesInOrder \n}\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid,diagonalallowed) {\n  const neighbors = [];\n  const {col, row} = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  if (diagonalallowed){\n    if (row > 0 && col > 0) neighbors.push(grid[row-1][col-1]);\n    if (row > 0 && col < grid[0].length - 1) neighbors.push(grid[row-1][col+1]);\n    if (row <  grid.length - 1 && col > 0 ) neighbors.push(grid[row+1][col-1]);\n    if (row <  grid.length - 1 && col < grid[0].length - 1) neighbors.push(grid[row+1][col+1]);\n    \n  }\n  return neighbors\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function bibfsans(node) {\n  // return [node];\n  var ans = []\n  let s = node ;  let e = node\n  while (s.previousNode !== null && e.nex !== null){\n    ans.unshift(s.previousNode);\n    ans.unshift(e.nex)\n    s = s.previousNode;\n    e = e.nex ;\n  }\n  while (s.previousNode !== null){\n    ans.unshift(s.previousNode);\n    s = s.previousNode;\n  }\n  while (e.nex !== null){\n    ans.unshift(e.nex);\n    e = e.nex ;\n  }\n  ans.push(node)\n  return ans\n}","//My variation of A star algorithm\n//Bi directional search of Dijkstra algorithm with heuristics\nimport _ from \"lodash\" ;\nexport function BiIastar(grid, startNode, finishNode,heuristic,diagonalallowed) {\n    const visitedNodesInOrder = []; //closed list\n    const TempEnd=[]; //Nodes from ending node till intersection node\n    const TempStart=[]; //Nodes from starting node till intersection node\n    const tempstart = _.cloneDeep(startNode);\n    tempstart.distance=0;\n    const tempend = _.cloneDeep(finishNode);\n    tempend.distance=0;\n    TempStart.push(tempstart);\n    TempEnd.push(tempend);\n    while (TempStart.length>0 && TempEnd.length>0) {\n      sortNodesByDistance(TempStart);\n      const closestNode = TempStart.shift();\n      // If we encounter a wall, we skip it.\n      if (closestNode.isWall && closestNode.wallweight==999999) \n      {\n        continue;\n      }\n      // If the closest node is at a distance of infinity,\n      // we must be trapped and should therefore stop.\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\n      closestNode.startvisited = true;\n      visitedNodesInOrder.push(closestNode);\n      updateUnvisitedNeighborsStart(closestNode, grid,finishNode,heuristic,diagonalallowed,TempStart,closestNode.wallweight);\n        if(closestNode === finishNode) \n        {\n      //console.log(\"Hello\");\n        var temp1 = [closestNode];\n        visitedNodesInOrder.unshift(temp1)\n        return visitedNodesInOrder;\n        }\n        //if the node with shortest distance is the intersection node\n        if (closestNode.endvisited)\n        {\n        // console.log(\"Hi\");\n        var temp2 = [closestNode];\n        visitedNodesInOrder.unshift(temp2)\n        return visitedNodesInOrder;\n        }\n        //Extract the node woth shortest distance from TempEnd\n        sortNodesByDistance(TempEnd);\n      const closestNode2 = TempEnd.shift();\n      // If we encounter a wall, we skip it.\n      if (closestNode2.isWall && closestNode2.wallweight==999999) continue;\n      // If the closest node is at a distance of infinity,\n      // we must be trapped and should therefore stop.\n      if (closestNode2.distance === Infinity) return visitedNodesInOrder;\n      closestNode2.endvisited = true;\n      updateUnvisitedNeighborsEnd(closestNode2, grid,finishNode,heuristic,diagonalallowed,TempEnd,closestNode2.wallweight);\n      visitedNodesInOrder.push(closestNode2);  \n      if(closestNode2 === startNode) \n        {\n      //console.log(\"Hello\");\n        var temp1 = [closestNode2];\n        visitedNodesInOrder.unshift(temp1)\n        return visitedNodesInOrder;\n        }\n        if (closestNode2.startvisited)\n        {\n        // console.log(\"Hi\");\n        var temp2 = [closestNode2];\n        visitedNodesInOrder.unshift(temp2)\n        return visitedNodesInOrder;\n        }\n    }\n    //If tempStart has nodes left within it\n    while(TempStart.length>0)\n    {\n        sortNodesByDistance(TempStart);\n      const closestNode = TempStart.shift();\n      // If we encounter a wall, we skip it.\n      if (closestNode.isWall && closestNode.wallweight==999999) continue;\n      // If the closest node is at a distance of infinity,\n      // we must be trapped and should therefore stop.\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\n      closestNode.startvisited = true;\n      visitedNodesInOrder.push(closestNode);\n      updateUnvisitedNeighborsStart(closestNode, grid,finishNode,heuristic,diagonalallowed,TempStart,closestNode.wallweight);\n      //If no intersection node is found  \n      if(closestNode === finishNode) \n        {\n      //console.log(\"Hello\");\n        var temp1 = [closestNode];\n        visitedNodesInOrder.unshift(temp1)\n        return visitedNodesInOrder;\n        }\n        //if intersection node is found we stop the search\n        if (closestNode.endvisited)\n        {\n        // console.log(\"Hi\");\n        var temp2 = [closestNode];\n        visitedNodesInOrder.unshift(temp2)\n        return visitedNodesInOrder;\n        }\n    }\n    //While Nodes in TempEnd are left\n    while(TempEnd.length>0)\n    {\n        sortNodesByDistance(TempEnd);\n        const closestNode2 = TempEnd.shift();\n        // If we encounter a wall, we skip it.\n        if (closestNode2.isWall && closestNode2.wallweight==999999) continue;\n        // If the closest node is at a distance of infinity,\n        // we must be trapped and should therefore stop.\n        if (closestNode2.distance === Infinity) return visitedNodesInOrder;\n        closestNode2.endvisited = true;\n        updateUnvisitedNeighborsEnd(closestNode2, grid,finishNode,heuristic,diagonalallowed,TempEnd,closestNode2.wallweight);\n        visitedNodesInOrder.push(closestNode2);  \n        //If intersection node is not found\n        if(closestNode2 === startNode) \n          {\n        //console.log(\"Hello\");\n          var temp1 = [closestNode2];\n          visitedNodesInOrder.unshift(temp1)\n          return visitedNodesInOrder;\n          }\n          //if intersection node is found we stop the search\n          if (closestNode2.startvisited)\n          {\n          // console.log(\"Hi\");\n          var temp2 = [closestNode2];\n          visitedNodesInOrder.unshift(temp2)\n          return visitedNodesInOrder;\n          }\n    }\n}\n  //to sort the nodes by distance\n  function sortNodesByDistance(unvisitedNodes) {\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n  }\n  //To update the heuristic of unvisited neighbors starting from start node\n  function updateUnvisitedNeighborsStart(node, grid,finishNode,heuristic,diagonalallowed,TempStart,wallweight) {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid,diagonalallowed);\n    for (const neighbor of unvisitedNeighbors) {\n        if (neighbor.startvisited) continue ;\n      var value; //here value variable will store the heuristic distance\n      var string=\"Manhattan\";\n      var string2=\"Diagonal\";\n      var string3=\"Euclidean\";\n      var string4=\"Octile\";\n      var string5=\"Chebyshev\";\n      if(heuristic.localeCompare(string)==0)\n      {\n        value=Math.abs(neighbor.row-finishNode.row)+Math.abs(neighbor.col-finishNode.col);\n        \n      }\n      else if(heuristic.localeCompare(string2)==0)\n      {\n        value=Math.max(Math.abs(neighbor.row-finishNode.row),Math.abs(neighbor.col-finishNode.col));\n       \n      }\n      else if(heuristic.localeCompare(string3)==0)\n      {\n        value=Math.sqrt(Math.pow((neighbor.row-finishNode.row),2)+Math.pow((neighbor.col-finishNode.col),2));\n        \n      }\n      else if(heuristic.localeCompare(string4)==0)\n      {\n        var x_dist=Math.abs(neighbor.row-finishNode.row);\n        var y_dist=Math.abs(neighbor.col-finishNode.col);\n        value=Math.max(x_dist,y_dist)+(Math.sqrt(2)-1) * Math.min(x_dist,y_dist);\n        \n      }\n      else if(heuristic.localeCompare(string5)==0)\n      {\n        value=Math.max(Math.abs(neighbor.row-finishNode.row),Math.abs(neighbor.col-finishNode.col));\n        \n      }\n      var temp= node.distance + wallweight*value; //adjusting the distance of the neighbor as nodes distance + penalty*heuristic\n      neighbor.distance=temp; //penalty will be 1 if neighbor is not a weighted wall otherwise weighted wall will have a penalty\n      neighbor.previousNode = node;\n          neighbor.startvisited = true;\n          TempStart.push(neighbor);\n    }\n  }\n  //To update the heuristic of unvisited neighbors starting from end node\n  function updateUnvisitedNeighborsEnd(node, grid,finishNode,heuristic,diagonalallowed,TempEnd,wallweight) {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid,diagonalallowed);\n    for (const neighbor of unvisitedNeighbors) {\n        if (neighbor.endvisited) continue ;\n      \n      var value; //here value variable will store the heuristic distance\n      var string=\"Manhattan\";\n      var string2=\"Diagonal\";\n      var string3=\"Euclidean\";\n      var string4=\"Octile\";\n      var string5=\"Chebyshev\";\n      if(heuristic.localeCompare(string)==0)\n      {\n        value=Math.abs(neighbor.row-finishNode.row)+Math.abs(neighbor.col-finishNode.col);\n       \n      }\n      else if(heuristic.localeCompare(string2)==0)\n      {\n        value=Math.max(Math.abs(neighbor.row-finishNode.row),Math.abs(neighbor.col-finishNode.col));\n        \n      }\n      else if(heuristic.localeCompare(string3)==0)\n      {\n        value=Math.sqrt(Math.pow((neighbor.row-finishNode.row),2)+Math.pow((neighbor.col-finishNode.col),2));\n        \n      }\n      else if(heuristic.localeCompare(string4)==0)\n      {\n        var x_dist=Math.abs(neighbor.row-finishNode.row);\n        var y_dist=Math.abs(neighbor.col-finishNode.col);\n        value=Math.max(x_dist,y_dist)+(Math.sqrt(2)-1) * Math.min(x_dist,y_dist);\n       \n      }\n      else if(heuristic.localeCompare(string5)==0)\n      {\n        value=Math.max(Math.abs(neighbor.row-finishNode.row),Math.abs(neighbor.col-finishNode.col));\n        \n      }\n      var temp= node.distance + value*wallweight; //adjusting the distance of the neighbor as nodes distance + penalty*heuristic\n      neighbor.distance=temp; //penalty will be 1 if neighbor is not a weighted wall otherwise weighted wall will have a penalty\n      neighbor.next=node; \n    // neighbor.previousNode = closestNodeEnd;\n     neighbor.endvisited = true; \n     TempEnd.push(neighbor);\n    }\n  }\n  //Get all neighbors\n  function getUnvisitedNeighbors(node, grid,diagonalallowed) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    if (diagonalallowed){\n      if (row > 0 && col > 0) neighbors.push(grid[row-1][col-1]);\n      if (row > 0 && col < grid[0].length - 1) neighbors.push(grid[row-1][col+1]);\n      if (row <  grid.length - 1 && col > 0 ) neighbors.push(grid[row+1][col-1]);\n      if (row <  grid.length - 1 && col < grid[0].length - 1) neighbors.push(grid[row+1][col+1]);\n      \n    }\n    return neighbors;\n  }\n  \n  \n  ","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid, startNode, finishNode,diagonalallowed) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (unvisitedNodes.length>0) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift(); //closestNode is the node with shortest distance\n    // If we encounter a wall, we skip it.\n    if ((closestNode.isWallweight || closestNode.isWall) && closestNode.wallweight==99999999) \n    {\n      //console.log(closestNode.wallweight);\n      continue;\n    }\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder; //if the shortest node is infinity then we return the visitedNodeinorder\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder; //if we reach the finish node then we return the visitedNodesInOrder\n    updateUnvisitedNeighbors(closestNode, grid,diagonalallowed,closestNode.wallweight);\n  }\n}\n//sort all nodes by distance\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n//update heuristic of unvisited neighbors\nfunction updateUnvisitedNeighbors(node, grid,diagonalallowed,wallweight) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid,diagonalallowed);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + wallweight; //making the neighbor distance as node.distance + wall weight\n    neighbor.previousNode = node; //making the node as previous node of neighbor\n    neighbor.isVisited=true;\n  }\n}\n//get all unvisited neighbors\nfunction getUnvisitedNeighbors(node, grid,diagonalallowed) {\n  const neighbors = [];\n  const {col, row} = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  if (diagonalallowed){\n    if (row > 0 && col > 0) neighbors.push(grid[row-1][col-1]);\n    if (row > 0 && col < grid[0].length - 1) neighbors.push(grid[row-1][col+1]);\n    if (row <  grid.length - 1 && col > 0 ) neighbors.push(grid[row+1][col-1]);\n    if (row <  grid.length - 1 && col < grid[0].length - 1) neighbors.push(grid[row+1][col+1]);\n    \n  }\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n//get all nodes of a grid\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","//My variation of A star algorithm\nexport function Iastar(grid, startNode, finishNode,heuristic,diagonalallowed) {\n    const visitedNodesInOrder = []; //closed list\n    startNode.distance = 0;\n    const unvisitedNodes = getAllNodes(grid); //open list\n    while (unvisitedNodes.length>0) {\n      sortNodesByDistance(unvisitedNodes); //extract the node with shortest distance\n      const closestNode = unvisitedNodes.shift();\n      // If we encounter a wall, we skip it.\n      if (closestNode.isWall && closestNode.wallweight==999999)\n      { \n        continue;\n      }\n      // If the closest node is at a distance of infinity,\n      // we must be trapped and should therefore stop.\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\n      closestNode.isVisited = true;\n      visitedNodesInOrder.push(closestNode);\n      if (closestNode === finishNode) return visitedNodesInOrder;  //when we reach the finishnode\n      updateUnvisitedNeighbors(closestNode, grid,finishNode,heuristic,diagonalallowed,closestNode.wallweight);\n    }\n  }\n  //sort nodes by distance\n  function sortNodesByDistance(unvisitedNodes) {\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n  }\n  //update the unvisited neighbors\n  function updateUnvisitedNeighbors(node, grid,finishNode,heuristic,diagonalallowed,wallweight) {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid,diagonalallowed);\n    for (const neighbor of unvisitedNeighbors) {\n      //console.log(finishNode.col);\n      //console.log(neighbor.col);\n      var value; //value variable stores heuristic distance\n      var string=\"Manhattan\";\n      var string2=\"Diagonal\";\n      var string3=\"Euclidean\";\n      var string4=\"Octile\";\n      var string5=\"Chebyshev\";\n      if(heuristic.localeCompare(string)==0)\n      {\n        value=Math.abs(neighbor.row-finishNode.row)+Math.abs(neighbor.col-finishNode.col);\n       \n      }\n      else if(heuristic.localeCompare(string2)==0)\n      {\n        value=Math.max(Math.abs(neighbor.row-finishNode.row),Math.abs(neighbor.col-finishNode.col));\n       \n      }\n      else if(heuristic.localeCompare(string3)==0)\n      {\n        value=Math.sqrt(Math.pow((neighbor.row-finishNode.row),2)+Math.pow((neighbor.col-finishNode.col),2));\n        \n      }\n      else if(heuristic.localeCompare(string4)==0)\n      {\n        var x_dist=Math.abs(neighbor.row-finishNode.row);\n        var y_dist=Math.abs(neighbor.col-finishNode.col);\n        value=Math.max(x_dist,y_dist)+(Math.sqrt(2)-1) * Math.min(x_dist,y_dist);\n        \n      }\n      else if(heuristic.localeCompare(string5)==0)\n      {\n        value=Math.max(Math.abs(neighbor.row-finishNode.row),Math.abs(neighbor.col-finishNode.col));\n       \n      }\n      neighbor.distance=value*wallweight+node.distance; //make the neighbor distance as heuristic*penalty+node.distance\n      neighbor.previousNode = node; //making the node as parent of neighbor node\n      neighbor.isVisited=true;\n    }\n  }\n  //get unvisited neighbors\n  function getUnvisitedNeighbors(node, grid,diagonalallowed) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    if (diagonalallowed){\n      if (row > 0 && col > 0) neighbors.push(grid[row-1][col-1]);\n      if (row > 0 && col < grid[0].length - 1) neighbors.push(grid[row-1][col+1]);\n      if (row <  grid.length - 1 && col > 0 ) neighbors.push(grid[row+1][col-1]);\n      if (row <  grid.length - 1 && col < grid[0].length - 1) neighbors.push(grid[row+1][col+1]);\n      \n    }\n    return neighbors.filter(neighbor => !neighbor.isVisited); //filter the unvisited neighbors\n  }\n  //get all nodes from the grid\n  function getAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n      for (const node of row) {\n        nodes.push(node);\n      }\n    }\n    return nodes;\n  }\n  \n  ","//Original implementation of Best First Search\nexport function IBestfs(grid, startNode, finishNode,heuristic,diagonalallowed) {\n    const visitedNodesInOrder = []; //closed list\n    startNode.distance = 0;\n    const unvisitedNodes = []; //open list\n    unvisitedNodes.push(startNode); \n    //Till unvisitedNodes is empty\n    while (unvisitedNodes.length>0) {\n      sortNodesByDistance(unvisitedNodes);\n      const closestNode = unvisitedNodes.shift(); //extract the node with shortest node\n      // If we encounter a wall, we skip it.\n      if (closestNode.isWall && closestNode.wallweight==99999999) continue;\n      // If the closest node is at a distance of infinity,\n      // we must be trapped and should therefore stop.\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\n      closestNode.isVisited = true; //make the isVisited of node with shortest distance as true\n      visitedNodesInOrder.push(closestNode);\n      if (closestNode === finishNode) //when we reach the finishNode\n      {\n        visitedNodesInOrder.push(closestNode);\n        return visitedNodesInOrder;\n      }   \n      updateUnvisitedNeighbors(closestNode, grid,finishNode,unvisitedNodes,heuristic,diagonalallowed,closestNode.wallweight);\n    }\n  }\n//sort all nodes by distance\n  function sortNodesByDistance(unvisitedNodes) {\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n  }\n  //update unvisited neighbors\n  function updateUnvisitedNeighbors(node, grid,finishNode,unvisitedNodes,heuristic,diagonalallowed,wallweight) {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid,diagonalallowed);\n    for (const neighbor of unvisitedNeighbors) {\n      \n      var value; //value stores the heuristic value of a function\n      var string=\"Manhattan\";\n      var string2=\"Diagonal\";\n      var string3=\"Euclidean\";\n      var string4=\"Octile\";\n      var string5=\"Chebyshev\";\n      if(heuristic.localeCompare(string)==0)\n      {\n        value=Math.abs(neighbor.row-finishNode.row)+Math.abs(neighbor.col-finishNode.col);\n        \n      }\n      else if(heuristic.localeCompare(string2)==0)\n      {\n        value=Math.max(Math.abs(neighbor.row-finishNode.row),Math.abs(neighbor.col-finishNode.col));\n        \n      }\n      else if(heuristic.localeCompare(string3)==0)\n      {\n        value=Math.sqrt(Math.pow((neighbor.row-finishNode.row),2)+Math.pow((neighbor.col-finishNode.col),2));\n        \n      }\n      else if(heuristic.localeCompare(string4)==0)\n      {\n        var x_dist=Math.abs(neighbor.row-finishNode.row);\n        var y_dist=Math.abs(neighbor.col-finishNode.col);\n        value=Math.max(x_dist,y_dist)+(Math.sqrt(2)-1) * Math.min(x_dist,y_dist);\n       \n      }\n      else if(heuristic.localeCompare(string5)==0)\n      {\n        value=Math.max(Math.abs(neighbor.row-finishNode.row),Math.abs(neighbor.col-finishNode.col));\n        \n      }\n      neighbor.distance=wallweight*value; //neighbor distance will be heuristic distance*penalty\n      neighbor.previousNode = node; \n      neighbor.isVisited = true; //making neighbor visited as true\n      unvisitedNodes.push(neighbor);\n    }\n  }\n  //get all unvisited neighbors\n  function getUnvisitedNeighbors(node, grid,diagonalallowed) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    //if diagonal is allowed then we can even allow nodes diagonal nodes in neighbor list\n    if (diagonalallowed){\n      if (row > 0 && col > 0) neighbors.push(grid[row-1][col-1]);\n      if (row > 0 && col < grid[0].length - 1) neighbors.push(grid[row-1][col+1]);\n      if (row <  grid.length - 1 && col > 0 ) neighbors.push(grid[row+1][col-1]);\n      if (row <  grid.length - 1 && col < grid[0].length - 1) neighbors.push(grid[row+1][col+1]);\n      \n    }\n    return neighbors.filter(neighbor => !neighbor.isVisited); //neighbors are filetered\n  }\n  \n  \n  ","export function IDAstar(grid, startNode, finishNode,heuristic,diagonalallowed) {\n    var depth=1;\n    while(1) //infinite loop\n    {\n        \n        var i=0;\n        getAllNodes(grid);\n        const visitedNodesInOrder = [];\n        var unvisitedNodes = []\n        startNode.distance = 0; //making the start node distance as 0\n        unvisitedNodes.push(startNode);\n        \n        while(i<depth)\n        {\n            //DFS till depth level\n            if(unvisitedNodes.length==0)\n            {\n                //console.log(\"Path not found\");\n                return visitedNodesInOrder;\n            }\n            //Sort nodes by distance\n            sortNodesByDistance(unvisitedNodes);\n            const closestNode = unvisitedNodes.shift(); //extract the shortest node\n            if (closestNode.isWall && closestNode.wallweight==99999999) continue;\n            // If the closest node is at a distance of infinity,\n            // we must be trapped and should therefore stop.\n            //extract the smallest node\n            if (closestNode.distance === Infinity) return visitedNodesInOrder; //if the closestNode is infinity then we stop the search\n            //if we reach the finishNode\n            if(closestNode === finishNode)\n            {\n                visitedNodesInOrder.push(finishNode)\n                return visitedNodesInOrder\n            }    \n            //console.log(closestNode);\n            closestNode.isVisited=true;\n            visitedNodesInOrder.push(closestNode);\n            const unvisitedNeighbors = getUnvisitedNeighbors(closestNode, grid,diagonalallowed);\n            \n            for (const neighbor of unvisitedNeighbors) {\n                var value; //value will have the heuristic distance\n                var string=\"Manhattan\";\n                var string2=\"Diagonal\";\n                var string3=\"Euclidean\";\n                var string4=\"Octile\";\n                var string5=\"Chebyshev\";\n                if(heuristic.localeCompare(string)==0)\n                {\n                    value=Math.abs(neighbor.row-finishNode.row)+Math.abs(neighbor.col-finishNode.col);\n                   \n                }\n                else if(heuristic.localeCompare(string2)==0)\n                {\n                    value=Math.max(Math.abs(neighbor.row-finishNode.row),Math.abs(neighbor.col-finishNode.col));\n                    \n                }\n                else if(heuristic.localeCompare(string3)==0)\n                {\n                    value=Math.sqrt(Math.pow((neighbor.row-finishNode.row),2)+Math.pow((neighbor.col-finishNode.col),2));\n                    \n                }\n                else if(heuristic.localeCompare(string4)==0)\n                {\n                    var x_dist=Math.abs(neighbor.row-finishNode.row);\n                    var y_dist=Math.abs(neighbor.col-finishNode.col);\n                    value=Math.max(x_dist,y_dist)+(Math.sqrt(2)-1) * Math.min(x_dist,y_dist);\n                    \n                }\n                else if(heuristic.localeCompare(string5)==0)\n                {\n                    value=Math.max(Math.abs(neighbor.row-finishNode.row),Math.abs(neighbor.col-finishNode.col));\n                    \n                }\n                neighbor.distance = value+closestNode.wallweight;\n                neighbor.previousNode = closestNode; //closestNode will become the previousNode of neighbor\n                neighbor.isVisited = true;//make the isVisited of neighbor node as true\n                unvisitedNodes.push(neighbor);\n                //if neighbor reaches finishNode\n                if (neighbor === finishNode)\n                { \n                    visitedNodesInOrder.push(finishNode);\n                    return visitedNodesInOrder;\n                }    \n            }\n            i=i+1;\n            //increase i by 1 \n            //i maintains the depth so far\n        \n        }\n    depth=depth+1;\n    //depth of DFS is increased by 1 everytime\n    }\n}\n//get all nodes\nfunction getAllNodes(grid) {\n    for (const row of grid) {\n      for (const node of row) {\n        node.isVisited = false;\n      }\n    }\n  }\n\n  //get unvisited neighbors\n  function getUnvisitedNeighbors(node, grid,diagonalallowed) {\n    const neighbors = [];\n    //console.log(node);\n    const col=node.col;\n    const row=node.row;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    if (diagonalallowed){\n        if (row > 0 && col > 0) neighbors.push(grid[row-1][col-1]);\n        if (row > 0 && col < grid[0].length - 1) neighbors.push(grid[row-1][col+1]);\n        if (row <  grid.length - 1 && col > 0 ) neighbors.push(grid[row+1][col-1]);\n        if (row <  grid.length - 1 && col < grid[0].length - 1) neighbors.push(grid[row+1][col+1]);\n        \n      }\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n  }\n  //sort nodes by distance\n  function sortNodesByDistance(unvisitedNodes) {\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n  }\n  \n  \n  \n","var Heap = require('heap');\nfunction heurestics(a,b,h){\n    if (h === 1){\n        // Euclidean\n       return Math.sqrt((b.row - a.row) ** 2 + (b.col - a.col) ** 2)\n    }\n    if (h === 2){\n        // Manhattan\n        return b.row - a.row + b.col - a.col\n    }\n    if (h === 3){\n        // octile\n        var a = Math.sqrt(2) - 1\n        var dx = b.row - a.row \n        var dy = b.col - a.col\n        return dx + dy + (a- 2)*Math.min(dx,dy)\n\n    }\n    if (h === 4){\n        // chebyshev\n        var dx = b.row - a.row \n        var dy = b.col - a.col\n        return Math.max(dx,dy)\n    }\n}\nfunction dblock(cX,cY,dX,dY,grid){\n    if (grid[cX-dX][cY].isWall && grid[cX][cY-dY].isWall){\n        return true\n    }\n    return false\n}\nfunction blocked(cX,cY,dX,dY,grid){\n    // console.log(\"check blocked\",cX,cY,dX,dY)\n    if (cX + dX < 0 || cX +dX >= grid.length){\n        return true\n    }\n    if (cY +dY <0 || cY +dY >= grid[0].length){\n        return true\n    }\n    if (dX !== 0 && dY !== 0){\n        if (grid[cX + dX][cY].isWall && grid[cX][cY+dY].isWall){\n            return true\n        }\n        if (grid[cX + dX][cY + dY].isWall){\n            return true\n        }\n    }\n    else{\n        if (dX !== 0){\n            if (grid[cX+dX][cY].isWall){\n                return true\n            }\n        }\n        else{\n            if (grid[cX][cY+dY].isWall){\n                return true\n            }\n        }\n    }\n    return false\n}\nfunction direction(a,b){\n    var dX = Math.sign(a.row-b.row)\n    var dY = Math.sign(a.col-b.col)\n    if (a.row-b.row === 0){\n        dX = 0\n    }\n    if (a.col-b.col === 0){\n        dY = 0\n    }\n    return [dX,dY]\n}\nfunction nodeNeighbors(node,parent,grid){\n    var neighbors = []\n    var cX = node.row ; var cY = node.col\n    if (parent == null){\n        var temp = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]\n        for (var i = 0 ; i< 8 ; i++){\n            var r = temp[i][0]\n            var c = temp[i][1]\n            if (!blocked(cX,cY,r,c,grid)){\n                neighbors.push(grid[cX+r][cY+c])\n            }\n        }\n        return neighbors\n    }\n    var x = direction(node,parent)\n    var dX = x[0] ; var dY = x[1];\n    if (dX !== 0 && dY !== 0){\n        if (!blocked(cX,cY,0,dY,grid)){\n            neighbors.push(grid[cX][cY+dY])\n        }\n        if (!blocked(cX,cY,dX,0,grid)){\n            neighbors.push(grid[cX+dX][cY])\n        }\n        if ((!blocked(cX, cY, 0, dY, grid) || !blocked(cX, cY, dX, 0, grid)) && (!blocked(cX, cY, dX, dY, grid))){\n            neighbors.push(grid[cX+dX][cY+dY])\n        }\n        if (blocked(cX, cY, -dX, 0, grid) && !blocked(cX, cY, 0, dY, grid) && !blocked(cX, cY, -dX, dY, grid)){\n            neighbors.push(grid[cX-dX][cY+dY])\n        }\n        if (blocked(cX, cY, 0, -dY, grid) && !blocked(cX, cY, dX, 0, grid) && !blocked(cX, cY, dX, -dY, grid)){\n            neighbors.push(grid[cX+dX][cY-dY])\n        }\n    }\n    else{\n        if (dX === 0){\n            if (!blocked(cX, cY, dX, 0, grid)){\n                if (!blocked(cX, cY, 0, dY, grid)){\n                    neighbors.push(grid[cX][cY+dY])\n                }\n                if (blocked(cX, cY, 1, 0, grid) && !blocked(cX, cY, 1, dY, grid)){\n                    neighbors.push(grid[cX+1][cY+dY])\n                }\n                if (blocked(cX, cY, -1, 0, grid) && !blocked(cX, cY, -1, dY, grid)){\n                    neighbors.push(grid[cX-1][cY+dY])\n                }\n            }\n        }\n        else{\n            if (!blocked(cX, cY, dX, 0, grid)){\n                if (!blocked(cX, cY, dX, 0, grid) && !blocked(cX, cY, dX, 0, grid)){\n                    neighbors.push(grid[cX+dX][cY])\n                }\n                if (blocked(cX, cY, 0, 1, grid) && !blocked(cX, cY, dX, 1, grid)){\n                    neighbors.push(grid[cX+dX][cY+1])\n                }\n                if (blocked(cX, cY, 0, -1, grid) && !blocked(cX, cY, dX, -1, grid)){\n                    neighbors.push(grid[cX+dX][dY-1])\n                }\n            }\n        }\n    }\n    return neighbors\n}\nfunction identifySuccessors(node,grid,finishNode){\n    var successors = []\n    var neighbors = nodeNeighbors(node,node.previousNode,grid)\n    for (var i = 0; i<neighbors.length;i++){\n        var neighbor = neighbors[i]\n        if (neighbor){\n            console.log(neighbor)\n            var dX = neighbor.row - node.row\n            var dY = neighbor.col - node.col\n            var jumpPoint = jump(node.row,node.col,dX,dY,grid,finishNode)\n            if (jumpPoint){\n                successors.push(jumpPoint)\n            }\n        }\n    }\n    return successors\n}\nfunction length(curr,jumpPoint,h){\n    return heurestics(curr,jumpPoint,h)\n}\nfunction jump(cX,cY,dX,dY,grid,finishNode){\n    var nX = cX + dX; var nY = cY + dY\n    if (blocked(nX, nY, 0, 0, grid)){\n        return\n    }\n    if (grid[nX][nY] === finishNode){\n        return finishNode;\n    }\n    var oX = nX ; var oY = nY\n    if (dX !== 0 && dY !== 0){\n        while (true){\n            if ((!blocked(oX, oY, -dX, dY, grid) && blocked(oX, oY, -dX, 0, grid)) || (!blocked(oX, oY, dX, -dY, grid) && blocked(oX, oY, 0, -dY, grid))){\n                return grid[oX][oY]\n            }\n            if (jump(oX, oY, dX, 0, grid, finishNode) || jump(oX, oY, 0, dY, grid, finishNode)){\n                return grid[oX][oY]\n            }\n            oX = oX + dX;\n            oY = oY + dY;\n            if (blocked(oX, oY, 0, 0, grid)){\n                return\n            }\n            if (dblock(oX, oY, dX, dY, grid)){\n                return \n            }\n            if (grid[oX][oY] === finishNode){\n                return finishNode\n            }\n        }\n    }\n    else{\n        if (dX !== 0){\n            while (true){\n                if ((!blocked(oX, nY, dX, 1, grid) && blocked(oX, nY, 0, 1, grid)) || (!blocked(oX, nY, dX, -1, grid) && blocked(oX, nY, 0, -1, grid))){\n                    return grid[oX][nY]\n                }\n                oX = oX + dX\n                if (blocked(oX, nY, 0, 0, grid)){\n                    return\n                }\n                if (grid[oX][nY] === finishNode){\n                    return finishNode\n                }\n            }\n        }\n        else{\n            while (true){\n                if ((!blocked(nX, oY, 1, dY, grid) && blocked(nX, oY, 1, 0, grid)) || (!blocked(nX, oY, -1, dY, grid) && blocked(nX, oY, -1, 0, grid))){\n                    return grid[nX][oY]\n                }\n                oY = oY + dY\n                if (blocked(nX, oY, 0, 0, grid)){\n                    return\n                }\n                if (grid[nX][oY] === finishNode){\n                    return finishNode\n                }\n\n            }\n        }\n    }\n    return jump(nX, nY, dX, dY, grid, finishNode)\n}\nexport function jps(grid,startNode,finishNode,h){\n    var openList = new Heap(function(nodeA, nodeB) {return nodeA.fscore - nodeB.fscore})\n    startNode.gscore = 0 ;\n    startNode.fscore = 0 ; \n    openList.push(startNode);\n    startNode.inopen = true;\n    const visitedNodesInOrder = [];\n    while (!openList.empty()){\n        var node = openList.pop();\n        node.inclosed = true;\n        visitedNodesInOrder.push(node)\n        if (node === finishNode){\n            return visitedNodesInOrder;\n        }\n        var successors = identifySuccessors(node,grid,finishNode);\n        for (var i = 0 ;i < successors.length;i++){\n            var successor = successors[i];\n            if (!successor.inclosed){\n                var val = node.gscore + length(node,successor,h)\n                if (!successor.inopen || val < successor.gscore){\n                    successor.gscore = val;\n                    successor.hscore = heurestics(successor,finishNode,h)\n                    successor.fscore = successor.gscore + successor.hscore\n                    successor.previousNode = node\n                    if (!successor.inopen){\n                        openList.push(successor)\n                        successor.inopen = true\n                    }\n                    else{\n                        openList.updateItem(successor)\n                    }\n                }\n            }\n        }\n    }\n    return visitedNodesInOrder\n}\nexport function jpsans(finishNode,grid,h){\n    var curr = finishNode\n    const nodesInShortestPathOrder = [];\n    while (curr !== null){\n        if (curr.previousNode){\n            var parent = curr.previousNode\n            var direc = direction(curr,parent)\n            var dX = direc[0] ; var dY = direc[1]\n            if ((dX === 0 && dY !== 0)|| (dY === 0 && dX !== 0)){\n                if (dY === 1){\n                    if (parent.col < curr.col){\n                        for (var a = parent.col + 1 ; a<curr.col ; a++){\n                            nodesInShortestPathOrder.push(grid[curr.row][a])\n                        }\n                    }\n                    else if (parent.col > curr.col){\n                        for (var b = parent.col ; b > curr.col ; b--){\n                            nodesInShortestPathOrder.push(grid[curr.row][b])\n                        }\n                    }\n                }\n                else{\n                    if (parent.row < curr.row){\n                        for (var c = parent.row + 1 ; c<curr.row ; c++){\n                            nodesInShortestPathOrder.push(grid[c][curr.col])\n                        }\n                    }\n                    else if (parent.row > curr.row){\n                        for (var d = parent.row  ; d > curr.row ; d--){\n                            nodesInShortestPathOrder.push(grid[d][curr.col])\n                        }\n                    }\n                }\n                nodesInShortestPathOrder.push(curr);\n                curr = curr.previousNode;\n            }\n            else{\n                if (parent.row < curr.row){\n                    var diff = parent.col - parent.row;\n                    for (var j = parent.row ; j < curr.row+1 ;j++){\n                        nodesInShortestPathOrder.push(grid[j][j+diff])\n                    }\n                }\n                if (parent.row > curr.row ){\n                    var diff = parent.col - parent.row;\n                    for (var l = parent.row ; l > curr.row+1 ;l++){\n                        nodesInShortestPathOrder.push(grid[l][l+diff])\n                    }\n                }\n                curr = curr.previousNode;\n            }\n        }\n        else{\n            nodesInShortestPathOrder.push(curr)\n            curr = curr.previousNode\n        }\n    \n    }\n    return nodesInShortestPathOrder\n\n}\n\n","var Heap = require('heap');\nfunction heurestics(a,b,h){\n    if (h === 1){\n        // Euclidean\n       return Math.sqrt((b.row - a.row) ** 2 + (b.col - a.col) ** 2)\n    }\n    if (h === 2){\n        // Manhattan\n        return b.row - a.row + b.col - a.col\n    }\n    if (h === 3){\n        // octile\n        var a = Math.sqrt(2) - 1\n        var dx = b.row - a.row \n        var dy = b.col - a.col\n        return dx + dy + (a- 2)*Math.min(dx,dy)\n\n    }\n    if (h === 4){\n        // chebyshev\n        var dx = b.row - a.row \n        var dy = b.col - a.col\n        return Math.max(dx,dy)\n    }\n}\nfunction dblock(cX,cY,dX,dY,grid){\n    if (grid[cX-dX][cY].isWall && grid[cX][cY-dY].isWall){\n        return true\n    }\n    return false\n}\nfunction blocked(cX,cY,dX,dY,grid){\n    // console.log(\"check blocked\",cX,cY,dX,dY)\n    if (cX + dX < 0 || cX +dX >= grid.length){\n        return true\n    }\n    if (cY +dY <0 || cY +dY >= grid[0].length){\n        return true\n    }\n    if (dX !== 0 && dY !== 0){\n        if (grid[cX + dX][cY].isWall && grid[cX][cY+dY].isWall){\n            return true\n        }\n        if (grid[cX + dX][cY + dY].isWall){\n            return true\n        }\n    }\n    else{\n        if (dX !== 0){\n            if (grid[cX+dX][cY].isWall){\n                return true\n            }\n        }\n        else{\n            if (grid[cX][cY+dY].isWall){\n                return true\n            }\n        }\n    }\n    return false\n}\nfunction direction(a,b){\n    var dX = Math.sign(a.row-b.row)\n    var dY = Math.sign(a.col-b.col)\n    if (a.row-b.row === 0){\n        dX = 0\n    }\n    if (a.col-b.col === 0){\n        dY = 0\n    }\n    return [dX,dY]\n}\nfunction nodeNeighbors(node,parent,grid){\n    var neighbors = []\n    var cX = node.row ; var cY = node.col\n    if (parent == null){\n        var temp = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]\n        for (var i = 0 ; i< 8 ; i++){\n            var r = temp[i][0]\n            var c = temp[i][1]\n            if (!blocked(cX,cY,r,c,grid)){\n                neighbors.push(grid[cX+r][cY+c])\n            }\n        }\n        return neighbors\n    }\n    var x = direction(node,parent)\n    var dX = x[0] ; var dY = x[1];\n    if (dX !== 0 && dY !== 0){\n        if (!blocked(cX,cY,0,dY,grid)){\n            neighbors.push(grid[cX][cY+dY])\n        }\n        if (!blocked(cX,cY,dX,0,grid)){\n            neighbors.push(grid[cX+dX][cY])\n        }\n        if ((!blocked(cX, cY, 0, dY, grid) || !blocked(cX, cY, dX, 0, grid)) && (!blocked(cX, cY, dX, dY, grid))){\n            neighbors.push(grid[cX+dX][cY+dY])\n        }\n        if (blocked(cX, cY, -dX, 0, grid) && !blocked(cX, cY, 0, dY, grid) && !blocked(cX, cY, -dX, dY, grid)){\n            neighbors.push(grid[cX-dX][cY+dY])\n        }\n        if (blocked(cX, cY, 0, -dY, grid) && !blocked(cX, cY, dX, 0, grid) && !blocked(cX, cY, dX, -dY, grid)){\n            neighbors.push(grid[cX+dX][cY-dY])\n        }\n    }\n    else{\n        if (dX === 0){\n            if (!blocked(cX, cY, dX, 0, grid)){\n                if (!blocked(cX, cY, 0, dY, grid)){\n                    neighbors.push(grid[cX][cY+dY])\n                }\n                if (blocked(cX, cY, 1, 0, grid) && !blocked(cX, cY, 1, dY, grid)){\n                    neighbors.push(grid[cX+1][cY+dY])\n                }\n                if (blocked(cX, cY, -1, 0, grid) && !blocked(cX, cY, -1, dY, grid)){\n                    neighbors.push(grid[cX-1][cY+dY])\n                }\n            }\n        }\n        else{\n            if (!blocked(cX, cY, dX, 0, grid)){\n                if (!blocked(cX, cY, dX, 0, grid) && !blocked(cX, cY, dX, 0, grid)){\n                    neighbors.push(grid[cX+dX][cY])\n                }\n                if (blocked(cX, cY, 0, 1, grid) && !blocked(cX, cY, dX, 1, grid)){\n                    neighbors.push(grid[cX+dX][cY+1])\n                }\n                if (blocked(cX, cY, 0, -1, grid) && !blocked(cX, cY, dX, -1, grid)){\n                    neighbors.push(grid[cX+dX][dY-1])\n                }\n            }\n        }\n    }\n    return neighbors\n}\nfunction identifySuccessors(node,grid,finishNode){\n    var successors = []\n    var neighbors = nodeNeighbors(node,node.previousNode,grid)\n    for (var i = 0; i<neighbors.length;i++){\n        var neighbor = neighbors[i]\n        if (neighbor){\n            // console.log(neighbor)\n            var dX = neighbor.row - node.row\n            var dY = neighbor.col - node.col\n            var jumpPoint = jump(node.row,node.col,dX,dY,grid,finishNode)\n            if (jumpPoint){\n                successors.push(jumpPoint)\n            }\n        }\n    }\n    return successors\n}\nfunction length(curr,jumpPoint,h){\n    return heurestics(curr,jumpPoint,h)\n}\nfunction jump(cX,cY,dX,dY,grid,finishNode,h){\n    var nX = cX + dX; var nY = cY + dY\n    if (blocked(nX, nY, 0, 0, grid)){\n        return\n    }\n    if (grid[nX][nY] === finishNode){\n        return finishNode;\n    }\n    var oX = nX ; var oY = nY\n    if (dX !== 0 && dY !== 0){\n        while (true){\n            if ((!blocked(oX, oY, -dX, dY, grid) && blocked(oX, oY, -dX, 0, grid)) || (!blocked(oX, oY, dX, -dY, grid) && blocked(oX, oY, 0, -dY, grid))){\n                return grid[oX][oY]\n            }\n            if (jump(oX, oY, dX, 0, grid, finishNode) || jump(oX, oY, 0, dY, grid, finishNode)){\n                return grid[oX][oY]\n            }\n            oX = oX + dX;\n            oY = oY + dY;\n            if (blocked(oX, oY, 0, 0, grid)){\n                return\n            }\n            if (dblock(oX, oY, dX, dY, grid)){\n                return \n            }\n            if (grid[oX][oY] === finishNode){\n                return finishNode\n            }\n        }\n    }\n    else{\n        if (dX !== 0){\n            while (true){\n                if ((!blocked(oX, nY, dX, 1, grid) && blocked(oX, nY, 0, 1, grid)) || (!blocked(oX, nY, dX, -1, grid) && blocked(oX, nY, 0, -1, grid))){\n                    return grid[oX][nY]\n                }\n                oX = oX + dX\n                if (blocked(oX, nY, 0, 0, grid)){\n                    return\n                }\n                if (grid[oX][nY] === finishNode){\n                    return finishNode\n                }\n            }\n        }\n        else{\n            while (true){\n                if ((!blocked(nX, oY, 1, dY, grid) && blocked(nX, oY, 1, 0, grid)) || (!blocked(nX, oY, -1, dY, grid) && blocked(nX, oY, -1, 0, grid))){\n                    return grid[nX][oY]\n                }\n                oY = oY + dY\n                if (blocked(nX, oY, 0, 0, grid)){\n                    return\n                }\n                if (grid[nX][oY] === finishNode){\n                    return finishNode\n                }\n\n            }\n        }\n    }\n    return jump(nX, nY, dX, dY, grid, finishNode)\n}\nexport function orthJPS(grid,startNode,finishNode,h){\n    var openList = new Heap(function(nodeA, nodeB) {return nodeA.fscore - nodeB.fscore})\n    startNode.gscore = 0 ;\n    startNode.fscore = 0 ; \n    openList.push(startNode);\n    startNode.inopen = true;\n    const visitedNodesInOrder = [];\n    while (!openList.empty()){\n        var node = openList.pop();\n        node.inclosed = true;\n        visitedNodesInOrder.push(node)\n        if (node === finishNode){\n            console.log(\"We have successfully found a path\")\n            return visitedNodesInOrder;\n        }\n        var successors = identifySuccessors(node,grid,finishNode);\n        for (var i = 0 ;i < successors.length;i++){\n            var successor = successors[i];\n            if (!successor.inclosed){\n                var val = node.gscore + length(node,successor,h)\n                if (!successor.inopen || val < successor.gscore){\n                    successor.gscore = val;\n                    successor.hscore = heurestics(successor,finishNode,h)\n                    successor.fscore = successor.gscore + successor.hscore\n                    successor.previousNode = node\n                    if (!successor.inopen){\n                        openList.push(successor)\n                        successor.inopen = true\n                    }\n                    else{\n                        openList.updateItem(successor)\n                    }\n                }\n            }\n        }\n    }\n    return visitedNodesInOrder\n}\nexport function orthogonalans(finishNode,grid){\n    var curr = finishNode\n    const nodesInShortestPathOrder = [];\n    while (curr !== null){\n        if (curr.previousNode){\n            var parent = curr.previousNode\n            var direc = direction(curr,parent)\n            var dX = direc[0] ; var dY = direc[1]\n            if ((dX === 0 && dY !== 0)|| (dY === 0 && dX !== 0)){\n                if (dY === 1){\n                    if (parent.col < curr.col){\n                        for (var a = parent.col + 1 ; a<curr.col ; a++){\n                            nodesInShortestPathOrder.push(grid[curr.row][a])\n                        }\n                    }\n                    else if (parent.col > curr.col){\n                        for (var b = parent.col ; b > curr.col ; b--){\n                            nodesInShortestPathOrder.push(grid[curr.row][b])\n                        }\n                    }\n                }\n                else{\n                    if (parent.row < curr.row){\n                        for (var c = parent.row + 1 ; c<curr.row ; c++){\n                            nodesInShortestPathOrder.push(grid[c][curr.col])\n                        }\n                    }\n                    else if (parent.row > curr.row){\n                        for (var d = parent.row  ; d > curr.row ; d--){\n                            nodesInShortestPathOrder.push(grid[d][curr.col])\n                        }\n                    }\n                }\n                nodesInShortestPathOrder.push(curr);\n                curr = curr.previousNode;\n            }\n            else{\n                var xcord = curr.row ; var ycord = parent.col;\n                if (parent.row < curr.row){\n                    for (var j = parent.row+1 ; j < xcord+1;j++){\n                        nodesInShortestPathOrder.push(grid[j][ycord]);\n                    }\n                }\n                else if (parent.row > curr.row){\n                    for (var k = parent.row-1 ; k>xcord +1;k--){\n                        nodesInShortestPathOrder.push(grid[k][ycord])\n                    }\n                }\n                if (parent.col < curr.col){\n                    for (var l = parent.col+1;l < curr.col ; l++){\n                        nodesInShortestPathOrder.push(grid[xcord][l])\n                    }\n                }\n                else if (parent.col > curr.col){\n                    for (var m = parent.col-1; m> curr.col ;m--){\n                        nodesInShortestPathOrder.push(grid[xcord][m])\n                    }\n                }\n                nodesInShortestPathOrder.push(curr);\n                curr = curr.previousNode;\n            }\n        }\n        else{\n            nodesInShortestPathOrder.push(curr)\n            curr = curr.previousNode\n        }\n    }\n    return nodesInShortestPathOrder\n\n}\n","import React, { Component } from \"react\";\nimport \"./Node.css\";\n\nexport default class Node extends Component {\n  sayhello() {\n    console.log(\"chutiye\");\n  }\n  render() {\n    const {\n      col,\n      isFinish,\n      isStart,\n      isWall,\n      isWallweight,\n      onDragStart,\n      draggable = false,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      onDrop,\n      row,\n    } = this.props;\n    const extraClassName = isFinish\n      ? \"node-finish\"\n      : isStart\n      ? \"node-start\"\n      : isWall\n      ? \"node-wall\"\n      : isWallweight\n      ? \"node-wallweight\"\n      : \"\";\n    window.ondragover = function (e) {\n      e.preventDefault();\n      return false;\n    };\n    window.ondrop = function (e) {\n      e.preventDefault();\n      return false;\n    };\n    const dragEnter = (e) => {\n      e.preventDefault();\n      e.target.style.background = \"rgba(113, 235, 52, 0.5)\";\n    };\n\n    const dragLeave = (e) => {\n      e.target.style.background = null;\n    };\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        dataS={isStart}\n        dataF={isFinish}\n        rowdata={row}\n        coldata={col}\n        draggable={draggable}\n        onMouseDown={() => !draggable && onMouseDown(row, col)}\n        onMouseEnter={() => !draggable && onMouseEnter(row, col)}\n        onMouseUp={() => !draggable && onMouseUp()}\n        onDragStart={(e) => draggable && onDragStart(e, isStart, isFinish)}\n        onDrop={(e) => !draggable && onDrop(e)}\n      ></div>\n    );\n  }\n}\n","//import React, { Component } from \"react\";\r\nimport React, { Component } from \"react\";\r\nimport { Astar } from \"../algorithms/astar\";\r\nimport { Bestfs } from \"../algorithms/Bestfs\";\r\nimport { bfs } from \"../algorithms/bfs\";\r\nimport { bidfsans, bidijkstra } from \"../algorithms/bi-dijkstra\";\r\nimport { BiAstar } from \"../algorithms/biastar\";\r\nimport { BiBestfs } from \"../algorithms/BiBestfs\";\r\nimport { bbfs, bibfsans } from \"../algorithms/bibfs\";\r\nimport { BiIastar } from \"../algorithms/BiIastar\";\r\nimport { dijkstra, getNodesInShortestPathOrder } from \"../algorithms/dijkstra\";\r\nimport { Iastar } from \"../algorithms/Iastar\";\r\nimport { IBestfs } from \"../algorithms/IBestfs\";\r\nimport { IDAstar } from \"../algorithms/IDAstar_new\";\r\nimport { jps, jpsans } from \"../algorithms/jps\";\r\nimport { orthJPS, orthogonalans } from \"../algorithms/orthJPS\";\r\nimport img1 from \"../images/marsmap1k.jpg\";\r\nimport Node from \"./Node\";\r\nimport \"./PathfindingVisualizer.css\";\r\n\r\nconst t_rows = 25;\r\nconst t_cols = 50;\r\n\r\nexport default class PathfindingVisualizer extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      grid: [],\r\n      wallweight: 99999999,\r\n      mouseIsPressed: false,\r\n      fin: false,\r\n      inf: false,\r\n      pause: false,\r\n      heuristic: 1, //\r\n      heuristicname: \"Euclidean\",\r\n      startnoderow: 4,\r\n      startnodecol: 17,\r\n      finishnoderow: 10,\r\n      finishnodecol: 38,\r\n      Algo: \"\",\r\n    };\r\n    this.handleheuristic1 = this.handleheuristic1.bind(this);\r\n    this.handleheuristic2 = this.handleheuristic2.bind(this);\r\n    this.handleheuristic3 = this.handleheuristic3.bind(this);\r\n    this.handleheuristic4 = this.handleheuristic4.bind(this);\r\n    this.handleOptionChangefinite = this.handleOptionChangefinite.bind(this);\r\n    this.handleOptionChangeinfinite = this.handleOptionChangeinfinite.bind(\r\n      this\r\n    );\r\n    // this.handleCheckfinite = this.handleCheckfinite.bind(this);\r\n    this.handleChange2 = this.handleChange2.bind(this);\r\n    this.handleSubmit = this.handleSubmit.bind(this);\r\n  }\r\n\r\n  handleheuristic1(event) {\r\n    this.state.heuristic = 1;\r\n    this.state.heuristicname = \"Euclidean\";\r\n  }\r\n  handleheuristic2(event) {\r\n    this.state.heuristic = 2;\r\n    this.state.heuristicname = \"Manhattan\";\r\n  }\r\n  handleheuristic3(event) {\r\n    this.state.heuristic = 3;\r\n    this.state.heuristicname = \"Octile\";\r\n  }\r\n  handleheuristic4(event) {\r\n    this.state.heuristic = 4;\r\n    this.state.heuristicname = \"Chebyshev\";\r\n  }\r\n\r\n  handleOptionChangefinite(event) {\r\n    if (!this.state.fin) {\r\n      this.state.fin = true;\r\n      this.state.wallweight = parseInt(\r\n        prompt(\"Please enter the value of wall weight\")\r\n      );\r\n      if (!this.state.wallweight) {\r\n        this.state.wallweight = 99999999;\r\n      }\r\n    }\r\n\r\n    //console.log(this.state.wallweight);\r\n  }\r\n  handleOptionChangeinfinite(event) {\r\n    if (this.state.fin) {\r\n      this.state.fin = false;\r\n      this.state.wallweight = 99999999;\r\n    }\r\n    //console.log(this.state.wallweight);\r\n  }\r\n  handleChange2(event) {\r\n    //console.log(\"getting weighted wall\");\r\n    this.setState({ wallweight: event.target.value });\r\n  }\r\n  handleSubmit(event) {\r\n    alert(\"A name was submitted: \" + this.state.wallweight);\r\n    event.preventDefault();\r\n  }\r\n  componentDidMount() {\r\n    const grid = getInitialGrid(\r\n      this.state.startnoderow,\r\n      this.state.startnodecol,\r\n      this.state.finishnoderow,\r\n      this.state.finishnodecol\r\n    );\r\n    this.setState({ grid });\r\n    console.log(\"component has mounted\");\r\n    document.body.style.backgroundImage = `url(${img1})`;\r\n  }\r\n\r\n  handleMouseDown(row, col) {\r\n    const newGrid = getNewGridWithWallToggled(\r\n      this.state.grid,\r\n      row,\r\n      col,\r\n      this.state.wallweight,\r\n      this.state.fin\r\n    );\r\n    this.setState({ grid: newGrid, mouseIsPressed: true });\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.mouseIsPressed) return;\r\n    const newGrid = getNewGridWithWallToggled(\r\n      this.state.grid,\r\n      row,\r\n      col,\r\n      this.state.wallweight,\r\n      this.state.fin\r\n    );\r\n    this.setState({ grid: newGrid });\r\n  }\r\n\r\n  handleonDragDrop = (e) => {\r\n    let row_i = e.dataTransfer.getData(\"row\");\r\n    let col_i = e.dataTransfer.getData(\"col\");\r\n    let row_f = e.target.getAttribute(\"rowdata\");\r\n    let col_f = e.target.getAttribute(\"coldata\");\r\n    let checkStart = e.dataTransfer.getData(\"infos\");\r\n    let checkFinish = e.dataTransfer.getData(\"infof\");\r\n    console.log(row_i, col_i, row_f, col_f, checkStart, checkFinish);\r\n    console.log(e.target);\r\n    const newGrid = newStartPositions(\r\n      this.state.grid,\r\n      row_i,\r\n      col_i,\r\n      row_f,\r\n      col_f,\r\n      checkStart,\r\n      checkFinish\r\n    );\r\n    console.log(checkStart, checkFinish);\r\n    this.setState({ grid: newGrid });\r\n    if (checkStart == \"true\" && checkFinish == \"false\") {\r\n      console.log(\"start is true\");\r\n      this.setState({ startnoderow: row_f });\r\n      this.setState({ startnodecol: col_f });\r\n    } else if (checkFinish == \"true\" && checkStart == \"false\") {\r\n      console.log(\"finish is true\");\r\n      this.setState({ finishnoderow: row_f });\r\n      this.setState({ finishnodecol: col_f });\r\n    }\r\n\r\n    //const col_i = id[]\r\n    //console.log(e.target);\r\n  };\r\n\r\n  handleMouseUp() {\r\n    this.setState({ mouseIsPressed: false });\r\n  }\r\n\r\n  handleonDragStart = (e, isStart, isFinish) => {\r\n    let r = e.target.getAttribute(\"rowdata\");\r\n    let c = e.target.getAttribute(\"coldata\");\r\n    let s = isStart;\r\n    let f = isFinish;\r\n    e.dataTransfer.setData(\"data\", `${e.target.id}`);\r\n    e.dataTransfer.setData(\"row\", `${r}`);\r\n    e.dataTransfer.setData(\"col\", `${c}`);\r\n    e.dataTransfer.setData(\"infos\", `${s}`);\r\n    e.dataTransfer.setData(\"infof\", `${f}`);\r\n    console.log(e.target);\r\n    //event.dataTransfer.setData(\"taskName\", );\r\n  };\r\n  // onDragOver = (event) => {\r\n  //   event.preventDefault();\r\n  // };\r\n\r\n  animate(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    for (let i = 1; i <= visitedNodesInOrder.length; i++) {\r\n      //console.log(this.state.pause);\r\n\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, 10 * i);\r\n        return;\r\n      }\r\n\r\n      if (\r\n        visitedNodesInOrder[i].isWall == false &&\r\n        visitedNodesInOrder[i].isWallweight == false\r\n      ) {\r\n        setTimeout(() => {\r\n          const node = visitedNodesInOrder[i];\r\n          if (!node.isStart && !node.isFinish) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              \"node node-visited\";\r\n          }\r\n        }, 10 * i);\r\n      }\r\n    }\r\n  }\r\n\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        if (node.isStart) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-start\";\r\n        }\r\n        if (!node.isStart && !node.isFinish) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-shortest-path\";\r\n        }\r\n        if (node.isFinish) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-finish\";\r\n        }\r\n      }, 50 * i);\r\n    }\r\n  }\r\n  visualizeOrthAstar() {\r\n    const { grid } = this.state;\r\n    this.state.Algo = \"Ort-Astar\";\r\n    const startNode = grid[this.state.startnoderow][this.state.startnodecol];\r\n    const finishNode = grid[this.state.finishnoderow][this.state.finishnodecol];\r\n    const visitedNodesInOrder = Astar(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      this.state.heuristic,\r\n      false\r\n    );\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n  visualizeAstar() {\r\n    const { grid } = this.state;\r\n    this.state.Algo = \"Astar\";\r\n\r\n    const startNode = grid[this.state.startnoderow][this.state.startnodecol];\r\n    const finishNode = grid[this.state.finishnoderow][this.state.finishnodecol];\r\n    const visitedNodesInOrder = Astar(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      this.state.heuristic,\r\n      true\r\n    );\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n  visualizeBiAstarWithDiagonals() {\r\n    const { grid } = this.state;\r\n    this.state.Algo = \"Bi+Diag-Astar\";\r\n    const startNode = grid[this.state.startnoderow][this.state.startnodecol];\r\n    const finishNode = grid[this.state.finishnoderow][this.state.finishnodecol];\r\n    const visitedNodesInOrder = BiAstar(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      this.state.heuristic,\r\n      true\r\n    );\r\n    const n = visitedNodesInOrder.shift();\r\n    //console.log(n[0].nex);\r\n    //console.log(n[0].previousNode);\r\n    const nodesInShortestPathOrder = bibfsans(n[0]);\r\n    this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n  visualizeBiAstarNodiagoanls() {\r\n    const { grid } = this.state;\r\n    this.state.Algo = \"Bi+Orth-Astar\";\r\n\r\n    const startNode = grid[this.state.startnoderow][this.state.startnodecol];\r\n    const finishNode = grid[this.state.finishnoderow][this.state.finishnodecol];\r\n    const visitedNodesInOrder = BiAstar(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      this.state.heuristic,\r\n      false\r\n    );\r\n    const n = visitedNodesInOrder.shift();\r\n    //console.log(n[0].nex);\r\n    //console.log(n[0].previousNode);\r\n    const nodesInShortestPathOrder = bibfsans(n[0]);\r\n    this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n  visualizeJPS() {\r\n    const { grid } = this.state;\r\n    this.state.Algo = \"JPS\";\r\n\r\n    const startNode = grid[this.state.startnoderow][this.state.startnodecol];\r\n    const finishNode = grid[this.state.finishnoderow][this.state.finishnodecol];\r\n    const visitedNodesInOrder = jps(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      this.state.heuristic\r\n    );\r\n    const nodesInShortestPathOrder = jpsans(finishNode, grid);\r\n    this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n  visualizeBFS() {\r\n    //console.log(this.state.wallweight);\r\n    this.state.Algo = \"BFS\";\r\n    this.clearFiniteWalls();\r\n\r\n    const { grid } = this.state;\r\n    const startNode = grid[this.state.startnoderow][this.state.startnodecol];\r\n    const finishNode = grid[this.state.finishnoderow][this.state.finishnodecol];\r\n    const visitedNodesInOrder = bfs(grid, startNode, finishNode, false);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n  visualizeBBFS() {\r\n    this.clearFiniteWalls();\r\n    this.state.Algo = \"Bi-BFS\";\r\n\r\n    const { grid } = this.state;\r\n    const startNode = grid[this.state.startnoderow][this.state.startnodecol];\r\n    const finishNode = grid[this.state.finishnoderow][this.state.finishnodecol];\r\n    const visitedNodesInOrder = bbfs(grid, startNode, finishNode, false);\r\n    const n = visitedNodesInOrder.shift();\r\n    //const nodesInShortestPathOrder = getNodesInShortestPathOrder(n[0]);\r\n    const nodesInShortestPathOrder = bibfsans(n[0]);\r\n    this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n  visualizeBDBFS() {\r\n    this.clearFiniteWalls();\r\n    this.state.Algo = \"Bi+Diag-BFS\";\r\n    const { grid } = this.state;\r\n    const startNode = grid[this.state.startnoderow][this.state.startnodecol];\r\n    const finishNode = grid[this.state.finishnoderow][this.state.finishnodecol];\r\n    const visitedNodesInOrder = bbfs(grid, startNode, finishNode, true);\r\n    const n = visitedNodesInOrder.shift();\r\n    //const nodesInShortestPathOrder = getNodesInShortestPathOrder(n[0]);\r\n    const nodesInShortestPathOrder = bibfsans(n[0]);\r\n    this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n  visualizeBFSwithdiagonals() {\r\n    this.clearFiniteWalls();\r\n    this.state.Algo = \"Diag-BFS\";\r\n    const { grid } = this.state;\r\n    const startNode = grid[this.state.startnoderow][this.state.startnodecol];\r\n    const finishNode = grid[this.state.finishnoderow][this.state.finishnodecol];\r\n    const visitedNodesInOrder = bfs(grid, startNode, finishNode, true);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n  visualizeOrthJPS() {\r\n    const { grid } = this.state;\r\n    this.state.Algo = \"Orth-JPS\";\r\n\r\n    const startNode = grid[this.state.startnoderow][this.state.startnodecol];\r\n    const finishNode = grid[this.state.finishnoderow][this.state.finishnodecol];\r\n    const visitedNodesInOrder = orthJPS(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      this.state.heuristic\r\n    );\r\n    const nodesInShortestPathOrder = orthogonalans(finishNode, grid);\r\n    this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n\r\n  //shreeya\r\n  visualizeDijkstra() {\r\n    const { grid } = this.state;\r\n    this.state.Algo = \"Dijkstra\";\r\n\r\n    const startNode = grid[this.state.startnoderow][this.state.startnodecol];\r\n    const finishNode = grid[this.state.finishnoderow][this.state.finishnodecol];\r\n    var diagonalallowed = false;\r\n    const visitedNodesInOrder = dijkstra(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n      //console.log(visitedNodesInOrder);\r\n      //console.log(nodesInShortestPathOrder);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      //console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n  visualizeIntelligentAstar() {\r\n    const { grid } = this.state;\r\n    this.state.Algo = \"I-Astar\";\r\n    const startNode = grid[this.state.startnoderow][this.state.startnodecol];\r\n    const finishNode = grid[this.state.finishnoderow][this.state.finishnodecol];\r\n    var heuristic = this.state.heuristicname;\r\n    var diagonalallowed = false;\r\n    const visitedNodesInOrder = Iastar(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      heuristic,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n      //console.log(visitedNodesInOrder);\r\n      //console.log(nodesInShortestPathOrder);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      //console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n  visualizeBiIntelligentAstar() {\r\n    const { grid } = this.state;\r\n    this.state.Algo = \"Bi-I-Astar\";\r\n    const startNode = grid[this.state.startnoderow][this.state.startnodecol];\r\n    const finishNode = grid[this.state.finishnoderow][this.state.finishnodecol];\r\n    var heuristic = this.state.heuristicname;\r\n    var diagonalallowed = false;\r\n    const visitedNodesInOrder = BiIastar(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      heuristic,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      //console.log(visitedNodesInOrder);\r\n      const ans = visitedNodesInOrder.shift();\r\n      //console.log(ans);\r\n      //console.log(ans[0]);\r\n      const tempo = grid[ans[0].row][ans[0].col];\r\n      const nodesInShortestPathOrder = bidfsans(tempo);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      //console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n  visualizeBestfs() {\r\n    const { grid } = this.state;\r\n    this.state.Algo = \"Bestfs\";\r\n    const startNode = grid[this.state.startnoderow][this.state.startnodecol];\r\n    const finishNode = grid[this.state.finishnoderow][this.state.finishnodecol];\r\n    var heuristic = \"Diagonal\";\r\n    var diagonalallowed = false;\r\n    const visitedNodesInOrder = Bestfs(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      heuristic,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n      //console.log(visitedNodesInOrder);\r\n      //console.log(nodesInShortestPathOrder);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      //console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n  visualizeIBestfs() {\r\n    const { grid } = this.state;\r\n    this.state.Algo = \"I-BestFS\";\r\n    const startNode = grid[this.state.startnoderow][this.state.startnodecol];\r\n    const finishNode = grid[this.state.finishnoderow][this.state.finishnodecol];\r\n    var heuristic = \"Diagonal\";\r\n    var diagonalallowed = false;\r\n    const visitedNodesInOrder = IBestfs(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      heuristic,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n      //console.log(visitedNodesInOrder);\r\n      //console.log(nodesInShortestPathOrder);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      //console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n  visualizeBiDijkstra() {\r\n    const { grid } = this.state;\r\n    this.state.Algo = \"Bi-Dijkstra\";\r\n    const startNode = grid[this.state.startnoderow][this.state.startnodecol];\r\n    const finishNode = grid[this.state.finishnoderow][this.state.finishnodecol];\r\n    var diagonalallowed = false;\r\n    const visitedNodesInOrder = bidijkstra(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      //console.log(visitedNodesInOrder);\r\n      const ans = visitedNodesInOrder.shift();\r\n      //console.log(ans);\r\n      //console.log(ans[0]);\r\n      const tempo = grid[ans[0].row][ans[0].col];\r\n      const nodesInShortestPathOrder = bidfsans(tempo);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      //console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n\r\n  visualizeBiBestfs() {\r\n    const { grid } = this.state;\r\n    this.state.Algo = \"Bi-Bestfs\";\r\n    const startNode = grid[this.state.startnoderow][this.state.startnodecol];\r\n    const finishNode = grid[this.state.finishnoderow][this.state.finishnodecol];\r\n    var heuristic = this.state.heuristicname;\r\n    var diagonalallowed = false;\r\n    const visitedNodesInOrder = BiBestfs(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      heuristic,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      //console.log(visitedNodesInOrder);\r\n      const ans = visitedNodesInOrder.shift();\r\n      //console.log(ans);\r\n      //console.log(ans[0]);\r\n      const tempo = grid[ans[0].row][ans[0].col];\r\n      const nodesInShortestPathOrder = bidfsans(tempo);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      //console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n  visualizeIDAstar() {\r\n    const { grid } = this.state;\r\n    this.state.Algo = \"IDA-STAR\";\r\n    const startNode = grid[this.state.startnoderow][this.state.startnodecol];\r\n    const finishNode = grid[this.state.finishnoderow][this.state.finishnodecol];\r\n    var heuristic = this.state.heuristicname;\r\n    var diagonalallowed = false;\r\n    const visitedNodesInOrder = IDAstar(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      heuristic,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n      //console.log(visitedNodesInOrder);\r\n      //console.log(nodesInShortestPathOrder);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      //console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n  visualizeDijkstraDiag() {\r\n    const { grid } = this.state;\r\n    this.state.Algo = \"Diag-Dijkstra\";\r\n    const startNode = grid[this.state.startnoderow][this.state.startnodecol];\r\n    const finishNode = grid[this.state.finishnoderow][this.state.finishnodecol];\r\n    var diagonalallowed = true;\r\n    const visitedNodesInOrder = dijkstra(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n      //console.log(visitedNodesInOrder);\r\n      //console.log(nodesInShortestPathOrder);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      //console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n  visualizeIntelligentAstarDiag() {\r\n    const { grid } = this.state;\r\n    this.state.Algo = \"DiagI-Astar-\";\r\n    const startNode = grid[this.state.startnoderow][this.state.startnodecol];\r\n    const finishNode = grid[this.state.finishnoderow][this.state.finishnodecol];\r\n    var heuristic = this.state.heuristicname;\r\n    var diagonalallowed = true;\r\n    const visitedNodesInOrder = Iastar(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      heuristic,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n      //console.log(visitedNodesInOrder);\r\n      //console.log(nodesInShortestPathOrder);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      //console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n  visualizeBiIntelligentAstarDiag() {\r\n    const { grid } = this.state;\r\n    this.state.Algo = \"BiDiag-I-Astar\";\r\n    const startNode = grid[this.state.startnoderow][this.state.startnodecol];\r\n    const finishNode = grid[this.state.finishnoderow][this.state.finishnodecol];\r\n    var heuristic = this.state.heuristicname;\r\n    var diagonalallowed = true;\r\n    const visitedNodesInOrder = BiIastar(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      heuristic,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      //console.log(visitedNodesInOrder);\r\n      const ans = visitedNodesInOrder.shift();\r\n      //console.log(ans);\r\n      //console.log(ans[0]);\r\n      const tempo = grid[ans[0].row][ans[0].col];\r\n      const nodesInShortestPathOrder = bidfsans(tempo);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      //console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n  visualizeBestfsDiag() {\r\n    const { grid } = this.state;\r\n    this.state.Algo = \"Diag-Bestfs\";\r\n    const startNode = grid[this.state.startnoderow][this.state.startnodecol];\r\n    const finishNode = grid[this.state.finishnoderow][this.state.finishnodecol];\r\n    var heuristic = \"Diagonal\";\r\n    var diagonalallowed = true;\r\n    const visitedNodesInOrder = Bestfs(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      heuristic,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n      //console.log(visitedNodesInOrder);\r\n      //console.log(nodesInShortestPathOrder);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      //console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n  visualizeIBestfsDiag() {\r\n    const { grid } = this.state;\r\n    this.state.Algo = \"Diag I-Bestfs\";\r\n    const startNode = grid[this.state.startnoderow][this.state.startnodecol];\r\n    const finishNode = grid[this.state.finishnoderow][this.state.finishnodecol];\r\n    var heuristic = \"Diagonal\";\r\n    var diagonalallowed = true;\r\n    const visitedNodesInOrder = IBestfs(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      heuristic,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n      //console.log(visitedNodesInOrder);\r\n      //console.log(nodesInShortestPathOrder);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      //console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n  visualizeBiDijkstraDiag() {\r\n    const { grid } = this.state;\r\n    this.state.Algo = \"BiDiag-Dijkstra\";\r\n    const startNode = grid[this.state.startnoderow][this.state.startnodecol];\r\n    const finishNode = grid[this.state.finishnoderow][this.state.finishnodecol];\r\n    var diagonalallowed = true;\r\n    const visitedNodesInOrder = bidijkstra(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      //console.log(visitedNodesInOrder);\r\n      const ans = visitedNodesInOrder.shift();\r\n      //console.log(ans);\r\n      //console.log(ans[0]);\r\n      const tempo = grid[ans[0].row][ans[0].col];\r\n      const nodesInShortestPathOrder = bidfsans(tempo);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      //console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n\r\n  visualizeBiBestfsDiag() {\r\n    const { grid } = this.state;\r\n    this.state.Algo = \"Bi+Diag Bestfs\";\r\n\r\n    const startNode = grid[this.state.startnoderow][this.state.startnodecol];\r\n    const finishNode = grid[this.state.finishnoderow][this.state.finishnodecol];\r\n    var heuristic = this.state.heuristicname;\r\n    var diagonalallowed = true;\r\n    const visitedNodesInOrder = BiBestfs(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      heuristic,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      //console.log(visitedNodesInOrder);\r\n      const ans = visitedNodesInOrder.shift();\r\n      //console.log(ans);\r\n      //console.log(ans[0]);\r\n      const tempo = grid[ans[0].row][ans[0].col];\r\n      const nodesInShortestPathOrder = bidfsans(tempo);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      //console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n  visualizeIDAstarDiag() {\r\n    const { grid } = this.state;\r\n    console.log(this.state.heuristicname);\r\n\r\n    this.state.Algo = \"Diag-IDAstar\";\r\n    console.log(this.state.Algo);\r\n    const startNode = grid[this.state.startnoderow][this.state.startnodecol];\r\n    const finishNode = grid[this.state.finishnoderow][this.state.finishnodecol];\r\n    var heuristic = this.state.heuristicname;\r\n    var diagonalallowed = true;\r\n    const visitedNodesInOrder = IDAstar(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      heuristic,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n      //console.log(visitedNodesInOrder);\r\n      //console.log(nodesInShortestPathOrder);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      //console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n  clearwall() {\r\n    const grid1 = this.state.grid;\r\n    for (let row = 0; row < t_rows; row++) {\r\n      for (let col = 0; col < t_cols; col++) {\r\n        const node = grid1[row][col];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node\";\r\n      }\r\n    }\r\n\r\n    const node = grid1[this.state.startnoderow][this.state.startnodecol];\r\n    document.getElementById(`node-${node.row}-${node.col}`).className =\r\n      \"node node-start\";\r\n    const node1 = grid1[this.state.finishnoderow][this.state.finishnodecol];\r\n    document.getElementById(`node-${node1.row}-${node1.col}`).className =\r\n      \"node node-finish\";\r\n    const grid2 = getInitialGrid(\r\n      this.state.startnoderow,\r\n      this.state.startnodecol,\r\n      this.state.finishnoderow,\r\n      this.state.finishnodecol\r\n    );\r\n    this.setState({ grid: grid2 });\r\n  }\r\n\r\n  pauseSearch() {\r\n    let bool1 = this.state.pause;\r\n    bool1 = true;\r\n    this.setState({ pause: bool1 });\r\n  }\r\n\r\n  clearPath() {\r\n    //console.log(\"calling clear path\");\r\n    const grid1 = this.state.grid;\r\n\r\n    for (let row = 0; row < t_rows; row++) {\r\n      for (let col = 0; col < t_cols; col++) {\r\n        let node = grid1[row][col];\r\n\r\n        if (!node.isWall && !node.isWallweight) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node\";\r\n        } else if (node.isWallweight) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-wallweight\";\r\n        }\r\n        node.distance = Infinity;\r\n        node.previousNode = null;\r\n        node.next = null;\r\n        node.nex = null;\r\n        node.gscore = Infinity;\r\n        node.hscore = Infinity;\r\n        node.fscore = Infinity;\r\n        node.inclosed = false;\r\n        node.inopen = false;\r\n        node.startvisited = false;\r\n        node.endvisited = false;\r\n        node.isVisited = false;\r\n      }\r\n    }\r\n    const node = grid1[this.state.startnoderow][this.state.startnodecol];\r\n    document.getElementById(`node-${node.row}-${node.col}`).className =\r\n      \"node node-start\";\r\n    const node1 = grid1[this.state.finishnoderow][this.state.finishnodecol];\r\n    document.getElementById(`node-${node1.row}-${node1.col}`).className =\r\n      \"node node-finish\";\r\n  }\r\n\r\n  clearFiniteWalls() {\r\n    const grid1 = this.state.grid;\r\n    for (let row = 0; row < t_rows; row++) {\r\n      for (let col = 0; col < t_cols; col++) {\r\n        const node = grid1[row][col];\r\n        if (node.isWallweight) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node\";\r\n          node.isWall = false;\r\n          node.wallweight = 1;\r\n          node.isWallweight = false;\r\n          node.distance = Infinity;\r\n          node.previousNode = null;\r\n          node.next = null;\r\n          node.nex = null;\r\n          node.gscore = Infinity;\r\n          node.hscore = Infinity;\r\n          node.fscore = Infinity;\r\n          node.inclosed = false;\r\n          node.inopen = false;\r\n          node.startvisited = false;\r\n          node.endvisited = false;\r\n          node.isVisited = false;\r\n        }\r\n      }\r\n    }\r\n    this.setState({ grid: grid1 });\r\n  }\r\n\r\n  render() {\r\n    const { grid, mouseIsPressed, wallweight, Algo } = this.state;\r\n\r\n    return (\r\n      <>\r\n        <div className=\"button-wrapper2\">\r\n          <div className=\"button2\">SELECT ALGORITHM</div>\r\n\r\n          <form id=\"app-cover\">\r\n            <div id=\"select-box\">\r\n              <input type=\"checkbox\" id=\"options-view-button\" value=\"ALGO\" />\r\n\r\n              <div class=\"mybutton\">\r\n                <a>Dijkstra Algorithm</a>\r\n              </div>\r\n\r\n              <div id=\"options\">\r\n                <div onClick={() => this.visualizeDijkstra()} class=\"option\">\r\n                  <input\r\n                    class=\"s-c top\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"codepen\"\r\n                  />\r\n                  <span class=\"label\">Dijkstra</span>\r\n                </div>\r\n\r\n                <div onClick={() => this.visualizeBiDijkstra()} class=\"option\">\r\n                  <input\r\n                    class=\"s-c top\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"dribbble\"\r\n                  />\r\n                  <span class=\"label\">Bi-directional</span>\r\n                </div>\r\n\r\n                <div\r\n                  onClick={() => this.visualizeDijkstraDiag()}\r\n                  class=\"option\"\r\n                >\r\n                  <input\r\n                    class=\"s-c top\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"behance\"\r\n                  />\r\n                  <input\r\n                    class=\"s-c bottom\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"behance\"\r\n                  />\r\n                  <span class=\"label\">Diagonal</span>\r\n                </div>\r\n\r\n                <div\r\n                  onClick={() => this.visualizeBiDijkstraDiag()}\r\n                  class=\"option\"\r\n                >\r\n                  <input\r\n                    class=\"s-c top\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"hackerrank\"\r\n                  />\r\n                  <span class=\"label\">BiDir+diagonal</span>\r\n                </div>\r\n\r\n                <div id=\"option-bg\"></div>\r\n              </div>\r\n            </div>\r\n          </form>\r\n\r\n          <form id=\"app-cover\">\r\n            <div id=\"select-box\">\r\n              <input type=\"checkbox\" id=\"options-view-button\" value=\"ALGO\" />\r\n\r\n              <div class=\"mybutton\">\r\n                <a>BFS Algorithm</a>\r\n              </div>\r\n\r\n              <div id=\"options\">\r\n                <div onClick={() => this.visualizeBFS()} class=\"option\">\r\n                  <input\r\n                    class=\"s-c top\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"codepen\"\r\n                  />\r\n                  <span class=\"label\">BFS</span>\r\n                </div>\r\n\r\n                <div onClick={() => this.visualizeBBFS()} class=\"option\">\r\n                  <input\r\n                    class=\"s-c top\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"dribbble\"\r\n                  />\r\n                  <span class=\"label\">Bi-directional</span>\r\n                </div>\r\n\r\n                <div\r\n                  onClick={() => this.visualizeBFSwithdiagonals()}\r\n                  class=\"option\"\r\n                >\r\n                  <input\r\n                    class=\"s-c top\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"behance\"\r\n                  />\r\n                  <input\r\n                    class=\"s-c bottom\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"behance\"\r\n                  />\r\n                  <span class=\"label\">Diagonal</span>\r\n                </div>\r\n\r\n                <div onClick={() => this.visualizeBDBFS()} class=\"option\">\r\n                  <input\r\n                    class=\"s-c top\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"hackerrank\"\r\n                  />\r\n                  <span class=\"label\">BiDir+diagonal</span>\r\n                </div>\r\n\r\n                <div id=\"option-bg\"></div>\r\n              </div>\r\n            </div>\r\n          </form>\r\n\r\n          <form id=\"app-cover\">\r\n            <div id=\"select-box\">\r\n              <input type=\"checkbox\" id=\"options-view-button\" value=\"ALGO\" />\r\n\r\n              <div class=\"mybutton\">\r\n                <a>Intelligent A-Star Algorithm</a>\r\n              </div>\r\n\r\n              <div id=\"options\">\r\n                <div\r\n                  onClick={() => this.visualizeIntelligentAstar()}\r\n                  class=\"option\"\r\n                >\r\n                  <input\r\n                    class=\"s-c top\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"codepen\"\r\n                  />\r\n                  <span class=\"label\">Int. A-Star</span>\r\n                </div>\r\n\r\n                <div\r\n                  onClick={() => this.visualizeBiIntelligentAstar()}\r\n                  class=\"option\"\r\n                >\r\n                  <input\r\n                    class=\"s-c top\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"dribbble\"\r\n                  />\r\n                  <span class=\"label\">Bi-directional</span>\r\n                </div>\r\n\r\n                <div\r\n                  onClick={() => this.visualizeIntelligentAstarDiag()}\r\n                  class=\"option\"\r\n                >\r\n                  <input\r\n                    class=\"s-c top\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"behance\"\r\n                  />\r\n                  <input\r\n                    class=\"s-c bottom\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"behance\"\r\n                  />\r\n                  <span class=\"label\">Diagonal</span>\r\n                </div>\r\n\r\n                <div\r\n                  onClick={() => this.visualizeBiIntelligentAstarDiag()}\r\n                  class=\"option\"\r\n                >\r\n                  <input\r\n                    class=\"s-c top\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"hackerrank\"\r\n                  />\r\n                  <span class=\"label\">BiDir+diagonal</span>\r\n                </div>\r\n\r\n                <div id=\"option-bg\"></div>\r\n              </div>\r\n            </div>\r\n          </form>\r\n\r\n          <form id=\"app-cover\">\r\n            <div id=\"select-box\">\r\n              <input type=\"checkbox\" id=\"options-view-button\" value=\"ALGO\" />\r\n\r\n              <div class=\"mybutton\">\r\n                <a>A-Star Algorithm</a>\r\n              </div>\r\n\r\n              <div id=\"options\">\r\n                <div onClick={() => this.visualizeAstar()} class=\"option\">\r\n                  <input\r\n                    class=\"s-c top\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"codepen\"\r\n                  />\r\n                  <span class=\"label\">A-Star</span>\r\n                </div>\r\n\r\n                <div\r\n                  onClick={() => this.visualizeBiAstarNodiagoanls()}\r\n                  class=\"option\"\r\n                >\r\n                  <input\r\n                    class=\"s-c top\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"dribbble\"\r\n                  />\r\n                  <span class=\"label\">Bi-directional</span>\r\n                </div>\r\n\r\n                <div onClick={() => this.visualizeOrthAstar()} class=\"option\">\r\n                  <input\r\n                    class=\"s-c top\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"behance\"\r\n                  />\r\n                  <input\r\n                    class=\"s-c bottom\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"behance\"\r\n                  />\r\n                  <span class=\"label\">Orthogonal</span>\r\n                </div>\r\n\r\n                <div\r\n                  onClick={() => this.visualizeBiAstarWithDiagonals()}\r\n                  class=\"option\"\r\n                >\r\n                  <input\r\n                    class=\"s-c top\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"hackerrank\"\r\n                  />\r\n                  <span class=\"label\">BiDir+diagonal</span>\r\n                </div>\r\n\r\n                <div id=\"option-bg\"></div>\r\n              </div>\r\n            </div>\r\n          </form>\r\n\r\n          <form id=\"app-cover\">\r\n            <div id=\"select-box\">\r\n              <input type=\"checkbox\" id=\"options-view-button\" value=\"ALGO\" />\r\n\r\n              <div class=\"mybutton\">\r\n                <a>Best first Search</a>\r\n              </div>\r\n\r\n              <div id=\"options\">\r\n                <div onClick={() => this.visualizeBestfs()} class=\"option\">\r\n                  <input\r\n                    class=\"s-c top\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"codepen\"\r\n                  />\r\n                  <span class=\"label\">Best First Search</span>\r\n                </div>\r\n\r\n                <div onClick={() => this.visualizeBiBestfs()} class=\"option\">\r\n                  <input\r\n                    class=\"s-c top\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"dribbble\"\r\n                  />\r\n                  <span class=\"label\">Bi-directional</span>\r\n                </div>\r\n\r\n                <div onClick={() => this.visualizeBestfsDiag()} class=\"option\">\r\n                  <input\r\n                    class=\"s-c top\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"behance\"\r\n                  />\r\n                  <input\r\n                    class=\"s-c bottom\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"behance\"\r\n                  />\r\n                  <span class=\"label\">Diagonal</span>\r\n                </div>\r\n\r\n                <div\r\n                  onClick={() => this.visualizeBiBestfsDiag()}\r\n                  class=\"option\"\r\n                >\r\n                  <input\r\n                    class=\"s-c top\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"hackerrank\"\r\n                  />\r\n                  <span class=\"label\">BiDir+diagonal</span>\r\n                </div>\r\n\r\n                <div id=\"option-bg\"></div>\r\n              </div>\r\n            </div>\r\n          </form>\r\n\r\n          <form id=\"app-cover\">\r\n            <div id=\"select-box\">\r\n              <input type=\"checkbox\" id=\"options-view-button\" value=\"ALGO\" />\r\n\r\n              <div class=\"mybutton\">\r\n                <a>Intelligent Best first Search</a>\r\n              </div>\r\n\r\n              <div id=\"options\">\r\n                <div onClick={() => this.visualizeIBestfs()} class=\"option\">\r\n                  <input\r\n                    class=\"s-c top\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"codepen\"\r\n                  />\r\n                  <span class=\"label\">Int. Best First</span>\r\n                </div>\r\n\r\n                <div onClick={() => this.visualizeIBestfsDiag()} class=\"option\">\r\n                  <input\r\n                    class=\"s-c top\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"behance\"\r\n                  />\r\n                  <input\r\n                    class=\"s-c bottom\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"behance\"\r\n                  />\r\n                  <span class=\"label\">Diagonal</span>\r\n                </div>\r\n\r\n                <div id=\"option-bg\"></div>\r\n              </div>\r\n            </div>\r\n          </form>\r\n\r\n          <form id=\"app-cover\">\r\n            <div id=\"select-box\">\r\n              <input type=\"checkbox\" id=\"options-view-button\" value=\"ALGO\" />\r\n\r\n              <div class=\"mybutton\">\r\n                <a>IDA Star</a>\r\n              </div>\r\n\r\n              <div id=\"options\">\r\n                <div onClick={() => this.visualizeIDAstar()} class=\"option\">\r\n                  <input\r\n                    class=\"s-c top\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"codepen\"\r\n                  />\r\n                  <span class=\"label\">IDA Star</span>\r\n                </div>\r\n\r\n                <div onClick={() => this.visualizeIDAstarDiag()} class=\"option\">\r\n                  <input\r\n                    class=\"s-c top\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"behance\"\r\n                  />\r\n                  <input\r\n                    class=\"s-c bottom\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"behance\"\r\n                  />\r\n                  <span class=\"label\">Diagonal</span>\r\n                </div>\r\n\r\n                <div id=\"option-bg\"></div>\r\n              </div>\r\n            </div>\r\n          </form>\r\n\r\n          <form id=\"app-cover\">\r\n            <div id=\"select-box\">\r\n              <input type=\"checkbox\" id=\"options-view-button\" value=\"ALGO\" />\r\n\r\n              <div class=\"mybutton\">\r\n                <a>Jump Point</a>\r\n              </div>\r\n\r\n              <div id=\"options\">\r\n                <div onClick={() => this.visualizeJPS()} class=\"option\">\r\n                  <input\r\n                    class=\"s-c top\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"codepen\"\r\n                  />\r\n                  <span class=\"label\">Jump Point</span>\r\n                </div>\r\n\r\n                <div onClick={() => this.visualizeOrthJPS()} class=\"option\">\r\n                  <input\r\n                    class=\"s-c top\"\r\n                    type=\"radio\"\r\n                    name=\"platform\"\r\n                    value=\"dribbble\"\r\n                  />\r\n                  <span class=\"label\">Orthogonal</span>\r\n                </div>\r\n\r\n                <div id=\"option-bg\"></div>\r\n              </div>\r\n            </div>\r\n          </form>\r\n\r\n          <div className=\"walls\">\r\n            WALLS\r\n            <div className=\"wallweight\">\r\n              <input\r\n                type=\"radio\"\r\n                id=\"radioApple\"\r\n                name=\"radioFruit\"\r\n                value=\"apple\"\r\n                checked={!this.state.fin}\r\n                onChange={this.handleOptionChangeinfinite}\r\n              />\r\n              <label for=\"radioApple\">Infinite Wall</label>\r\n\r\n              <input\r\n                type=\"radio\"\r\n                id=\"radioBanana\"\r\n                name=\"radioFruit\"\r\n                value=\"banana\"\r\n                checked={this.state.fin}\r\n                onChange={this.handleOptionChangefinite}\r\n              />\r\n              <label for=\"radioBanana\">Finite Wall</label>\r\n              <input\r\n                type=\"radio\"\r\n                id=\"walltext\"\r\n                name=\"radioFruit\"\r\n                value=\"banana\"\r\n              />\r\n              <label for=\"walltext\">Wall Weight:</label>\r\n              <input\r\n                type=\"radio\"\r\n                id=\"wall-value\"\r\n                name=\"radioFruit\"\r\n                value=\"banana\"\r\n              />\r\n              <label for=\"wall-value\">{wallweight}</label>\r\n            </div>\r\n          </div>\r\n          <div className=\"currentAlgo\">\r\n            Currrent-Algo\r\n            <div className=\"running\">\r\n              <input\r\n                type=\"radio\"\r\n                id=\"runningAlgo\"\r\n                name=\"radioFruit\"\r\n                value=\"apple\"\r\n              />\r\n              <label for=\"runningAlgo\">{Algo}</label>\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        <div className=\"inibutt\">\r\n          <div className=\"startendwrap\">\r\n            <div\r\n              className=\"pauseresume\"\r\n              tabIndex=\"2\"\r\n              onClick={() =>\r\n                alert(`     The search has been Paused\r\n                    Click on OK to resume`)\r\n              }\r\n            ></div>\r\n          </div>\r\n\r\n          <div className=\"iniwrap\">\r\n            <div className=\"pathwall\" onClick={(grid) => this.clearPath(grid)}>\r\n              Clear Path\r\n            </div>\r\n          </div>\r\n\r\n          <div className=\"startendwrap\">\r\n            <div\r\n              onClick={async () => {\r\n                window.location =\r\n                  \"https://hackgod2000.github.io/TouchDown.js/#/end\";\r\n              }}\r\n              className=\"startend2\"\r\n            >\r\n              END\r\n            </div>\r\n          </div>\r\n\r\n          <div className=\"iniwrap\">\r\n            <div className=\"pathwall\" onClick={(grid) => this.clearwall(grid)}>\r\n              Clear Wall\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        <div className=\"gridradio\">\r\n          <div className=\"radiowrapper\">\r\n            HEURISTICS\r\n            <div class=\"radiobutton\">\r\n              <input\r\n                type=\"radio\"\r\n                id=\"euclidian\"\r\n                name=\"radiowall\"\r\n                value=\"euclidean\"\r\n                checked={this.state.heuristic === 1}\r\n                onChange={this.handleheuristic1}\r\n              />\r\n              <label for=\"euclidean\">Euclidean</label>\r\n            </div>\r\n            <div class=\"radiobutton\">\r\n              <input\r\n                type=\"radio\"\r\n                id=\"manhattan\"\r\n                name=\"radiowall\"\r\n                value=\"manhattan\"\r\n                checked={this.state.heuristic === 2}\r\n                onChange={this.handleheuristic2}\r\n              />\r\n              <label for=\"manhattan\">Manhattan</label>\r\n            </div>\r\n            <div class=\"radiobutton\">\r\n              <input\r\n                type=\"radio\"\r\n                id=\"octile\"\r\n                name=\"radiowall\"\r\n                value=\"octile\"\r\n                checked={this.state.heuristic === 3}\r\n                onChange={this.handleheuristic3}\r\n              />\r\n              <label for=\"octile\">Octile</label>\r\n            </div>\r\n            <div class=\"radiobutton\">\r\n              <input\r\n                type=\"radio\"\r\n                id=\"chebyshev\"\r\n                name=\"radiowall\"\r\n                value=\"chebyshev\"\r\n                checked={this.state.heuristic === 4}\r\n                onChange={this.handleheuristic4}\r\n              />\r\n              <label for=\"chebyshev\">Chebyshev</label>\r\n            </div>\r\n          </div>\r\n\r\n          <div className=\"grid\">\r\n            {grid.map((row, rowIdx) => {\r\n              return (\r\n                <div key={rowIdx}>\r\n                  {row.map((node, nodeIdx) => {\r\n                    const {\r\n                      row,\r\n                      col,\r\n                      isFinish,\r\n                      isStart,\r\n                      isWall,\r\n                      isWallweight,\r\n                    } = node;\r\n                    if (isStart || isFinish) {\r\n                      //console.log(\"yo\");\r\n                      return (\r\n                        <Node\r\n                          key={nodeIdx}\r\n                          col={col}\r\n                          isFinish={isFinish}\r\n                          isStart={isStart}\r\n                          draggable={true}\r\n                          isWall={isWall}\r\n                          isWallweight={isWallweight}\r\n                          mouseIsPressed={mouseIsPressed}\r\n                          onDragStart={(e, isStart, isFinish) =>\r\n                            this.handleonDragStart(e, isStart, isFinish)\r\n                          }\r\n                          onDrop={(e) => this.handleonDragDrop(e)}\r\n                          //onDragOver={(event) => this.onDragOver(event)}\r\n                          onMouseDown={(row, col) =>\r\n                            this.handleMouseDown(row, col)\r\n                          }\r\n                          onMouseEnter={(row, col) =>\r\n                            this.handleMouseEnter(row, col)\r\n                          }\r\n                          onMouseUp={() => this.handleMouseUp()}\r\n                          row={row}\r\n                        ></Node>\r\n                      );\r\n                    } else {\r\n                      return (\r\n                        <Node\r\n                          key={nodeIdx}\r\n                          col={col}\r\n                          isFinish={isFinish}\r\n                          draggable={false}\r\n                          isStart={isStart}\r\n                          isWall={isWall}\r\n                          isWallweight={isWallweight}\r\n                          mouseIsPressed={mouseIsPressed}\r\n                          onDragStart={(e, isStart, isFinish) =>\r\n                            this.handleonDragStart(e, isStart, isFinish)\r\n                          }\r\n                          onDrop={(e) => this.handleonDragDrop(e)}\r\n                          //onDragOver={(event) => this.onDragOver(event)}\r\n                          onMouseDown={(row, col) =>\r\n                            this.handleMouseDown(row, col)\r\n                          }\r\n                          onMouseEnter={(row, col) =>\r\n                            this.handleMouseEnter(row, col)\r\n                          }\r\n                          onMouseUp={() => this.handleMouseUp()}\r\n                          row={row}\r\n                        ></Node>\r\n                      );\r\n                    }\r\n                  })}\r\n                </div>\r\n              );\r\n            })}\r\n          </div>\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nconst getInitialGrid = (\r\n  startnoderow,\r\n  startnodecol,\r\n  finishnoderow,\r\n  finishnodecol\r\n) => {\r\n  const grid = [];\r\n  for (let row = 0; row < t_rows; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < t_cols; col++) {\r\n      currentRow.push(\r\n        createNode(\r\n          col,\r\n          row,\r\n          startnoderow,\r\n          startnodecol,\r\n          finishnoderow,\r\n          finishnodecol\r\n        )\r\n      );\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  return grid;\r\n};\r\n\r\nconst createNode = (\r\n  col,\r\n  row,\r\n  startnoderow,\r\n  startnodecol,\r\n  finishnoderow,\r\n  finishnodecol\r\n) => {\r\n  console.log(startnoderow, startnodecol, finishnoderow, finishnodecol);\r\n  return {\r\n    col,\r\n    row,\r\n    isStart: row == startnoderow && col == startnodecol,\r\n    isFinish: row == finishnoderow && col == finishnodecol,\r\n    distance: Infinity,\r\n    isVisited: false,\r\n    isWall: false,\r\n    isWallweight: false,\r\n    wallweight: 1,\r\n    previousNode: null,\r\n    gscore: Infinity,\r\n    fscore: Infinity,\r\n    hscore: Infinity,\r\n    inclosed: false,\r\n    inopen: false,\r\n    startvisited: false,\r\n    endvisited: false,\r\n    nex: null,\r\n    next: null,\r\n  };\r\n};\r\nconst getNewGridWithWallToggled = (grid, row, col, weight, fin) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  console.log(node.isStart);\r\n  const newNode = {\r\n    ...node,\r\n    isWall: !node.isWall && !fin,\r\n    isWallweight: !node.isWallweight && fin,\r\n  };\r\n  if (newNode.isWall || newNode.isWallweight) {\r\n    newNode.wallweight = weight;\r\n  }\r\n  newGrid[row][col] = newNode;\r\n  //console.log(newGrid[row][col]);\r\n  return newGrid;\r\n};\r\n\r\nconst newStartPositions = (\r\n  grid,\r\n  row_i,\r\n  col_i,\r\n  row_f,\r\n  col_f,\r\n  checkStart,\r\n  checkFinish\r\n) => {\r\n  const newGrid = grid.slice();\r\n  const node_old = newGrid[row_i][col_i];\r\n  const newNode = {\r\n    ...node_old,\r\n    isStart: false,\r\n    isFinish: false,\r\n  };\r\n  newGrid[row_i][col_i] = newNode;\r\n  const node_new = newGrid[row_f][col_f];\r\n  console.log(checkStart, checkFinish);\r\n  let start = false;\r\n  let end = false;\r\n  if (checkStart == \"true\" && checkFinish == \"false\") {\r\n    start = true;\r\n    end = false;\r\n  }\r\n  if (checkStart == \"false\" && checkFinish == \"true\") {\r\n    start = false;\r\n    end = true;\r\n  }\r\n\r\n  const newNode1 = {\r\n    ...node_new,\r\n    isStart: start,\r\n    isFinish: end,\r\n  };\r\n  newGrid[row_f][col_f] = newNode1;\r\n  return newGrid;\r\n};\r\n","import React from \"react\";\r\nimport { HashRouter as Router, Route, Switch } from \"react-router-dom\";\r\nimport Endpage from \"./Components/endpage\";\r\nimport Model from \"./Components/Model\";\r\nimport PathfindingVisualizer from \"./Components/PathfindingVisualizer/PathfindingVisualizer\";\r\n\r\nfunction App() {\r\n  return (\r\n    <Router>\r\n      <Switch>\r\n        <div className=\"App\">\r\n          <Route exact path=\"/\">\r\n            <Model />\r\n          </Route>\r\n          <Route path=\"/algo\">\r\n            <PathfindingVisualizer />\r\n          </Route>\r\n          <Route path=\"/end\">\r\n            <Endpage />\r\n          </Route>\r\n        </div>\r\n      </Switch>\r\n    </Router>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport App from \"./App\";\r\nimport * as serviceWorker from \"./serviceWorker\";\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById(\"root\")\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}